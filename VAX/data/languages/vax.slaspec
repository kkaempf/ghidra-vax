# sleigh specification file for DEC VAX

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# processor registers
define register offset=0x100 size=4 [ KSP   ESP  SSP  USP    ISP  
                                      P0BR  P0LR P1BR P1LR   SBR  SLR  CPUID
                                      PCBB  SCBB IPL  ASTLVL SIRR SISR
                                      ICCS  NICR ICR  TODR
                                      RXCS  RXDB TXCS TXDB
                                      x2a x2b
                                      MAPEN TBIA TBIS             PME  SID TBCHK
                                      VPSR  VAER VMAC VTBIA  VSAR ];

# status bits within PSW
#define bitrange C=PSW[0,1]
#                V=PSW[1,1]
#                Z=PSW[2,1]
#                N=PSW[3,1]
#                T=PSW[4,1]
#               IV=PSW[5,1]
#               FU=PSW[6,1]
#               DV=PSW[7,1]
#;

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode = (0,7)
;

# addressing
define token addrmode (8)
        mode67  = (6,7) # literal if mode67 = 0
        litval  = (0,5) # 6-bit literal unsigned
        mode    = (4,7) # mode
        reg     = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor register
define token preg (8)
        procreg = (0,7)
;

attach variables [ procreg ] [ KSP   ESP  SSP  USP    ISP  _    _     _   #  0 -
                               P0BR  P0LR P1BR P1LR   SBR  SLR  CPUID _   #  8 -
                               PCBB  SCBB IPL  ASTLVL SIRR SISR _     _   # 16 -
                               ICCS  NICR ICR  TODR   _    _    _     _   # 24 -
                               RXCS  RXDB TXCS TXDB   _    _    _     _   # 32 -
                               _     _    x2a  x2b    _    _    _     _   # 40 -
                               _     _    _    _      _    _    _     _   # 48 -
                               MAPEN TBIA TBIS _      _    PME  SID TBCHK # 56 -
                               _     _    _    _      _    _    _     _   # 64
                               _     _    _    _      _    _    _     _   # 72
                               _     _    _    _      _    _    _     _   # 80
                               _     _    _    _      _    _    _     _   # 88
                               _     _    _    _      _    _    _     _   # 96
                               _     _    _    _      _    _    _     _   # 104
                               _     _    _    _      _    _    _     _   # 112
                               _     _    _    _      _    _    _     _   # 120
                               _     _    _    _      _    _    _     _   # 128
                               _     _    _    _      _    _    _     _   # 136
                               VPSR  VAER VMAC VTBIA  VSAR _    _     _   # 144
                               _     _    _    _      _    _    _     _   # 152
                               _     _    _    _      _    _    _     _   # 160
                               _     _    _    _      _    _    _     _   # 168
                               _     _    _    _      _    _    _     _   # 176
                               _     _    _    _      _    _    _     _   # 184
                               _     _    _    _      _    _    _     _   # 192
                               _     _    _    _      _    _    _     _   # 200
                               _     _    _    _      _    _    _     _   # 208
                               _     _    _    _      _    _    _     _   # 216
                               _     _    _    _      _    _    _     _   # 224
                               _     _    _    _      _    _    _     _   # 232
                               _     _    _    _      _    _    _     _   # 240
                               _     _    _    _      _    _    _     _   # 248
                               ];

# effective addresses

# 0-3: literal
src_b: "S^#"^litval is mode67=0 & litval { tmp:1 = litval; export tmp; }
src_w: "S^#"^litval is mode67=0 & litval { tmp:2 = litval; export tmp; }
src_l: "S^#"^litval is mode67=0 & litval { export litval; }

# 4: indexed
#src_l: src_l[reg] is mode=4 & reg & src_l { tmp:4 = reg + src_l; export tmp; }

# 5: register
src_b: reg is mode=5 & reg { tmp = reg:1; export tmp; }
src_w: reg is mode=5 & reg { tmp = reg:2; export tmp; }
src_l: reg is mode=5 & reg { export reg; }

# 6: register deferred
src_b: (reg) is mode=6 & reg { export *:1 reg; }
src_w: (reg) is mode=6 & reg { export *:2 reg; }
src_l: (reg) is mode=6 & reg { export *reg; }

# 7x: auto decrement
src_b: -(reg) is mode=7 & reg { reg = reg - 1; export *:1 reg; }
src_w: -(reg) is mode=7 & reg { reg = reg - 2; export *:2 reg; }
src_l: -(reg) is mode=7 & reg { reg = reg - 4; export *reg; }

# 8f immediate
src_b: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
# 8x: auto increment
src_b: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 1; export *:1 tmp; }
src_w: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
src_w: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 2; export *:2 tmp; }
src_l: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
src_l: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

# 9f: absolute
src_l: "@#"^imm32 is mode=9 & reg=15; imm32 { export imm32; }
# 9x: auto increment deferred
src_l: @(reg)+ is mode=9 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

# af: byte relative
#src_l: "B^"^simm8^"(PC)" is mode=10 & reg=15; simm8 { tmp = inst_next + simm8; export *:4 tmp; }
# ax: byte displacement
src_l: "B^"^simm8(reg) is mode=10 & reg; simm8 { tmp = reg + simm8; export *:4 tmp; }

# bf: byte relative deferred
#src_l: "@B^"^simm8^"(PC)" is mode=11 & reg=15; simm8 { tmp = inst_next + simm8; export *:4 tmp; }
# bx: byte displacement deferred
src_l: "@B^"^simm8(reg) is mode=11 & reg; simm8 { tmp = reg + simm8; export *:4 tmp; }

# cf: word relative
#src_l: "W^"^simm16^"(PC)" is mode=12 & reg=15; simm16 { tmp = inst_next + simm16; export *:4 tmp; }
# cx: word displacement
src_l: "W^"^simm16(reg) is mode=12 & reg; simm16 { tmp = reg + simm16; export *:4 tmp; }

# df: word relative deferred
#src_l: "@W^"^simm16^"(PC)" is mode=13 & reg=15; simm16 { tmp = inst_next + simm16; export *:4 tmp; }
# dx: word displacement deferred
src_l: "@W^"^simm16(reg) is mode=13 & reg; simm16 { tmp = reg + simm16; export *:4 tmp; }

# ef: longword relative
#src_l: "L^"^simm32^"(PC)" is mode=14 & reg=15; simm32 { tmp = inst_next + simm32; export *:4 tmp; }
# ex: longword displacement
src_l: "L^"^simm32(reg) is mode=14 & reg; simm32 { tmp = reg + simm32; export *:4 tmp; }

# ff: longword relative deferred
#src_l: "@L^"^simm32^"(PC)" is mode=15 & reg=15; simm32 { tmp = inst_next + simm32; export *:4 tmp; }
# fx: longword displacement deferred
src_l: "@L^"^simm32(reg) is mode=15 & reg; simm32 { tmp = reg + simm32; export *:4 tmp; }

#   dest

dest_b: src_b is src_b { export src_b; }
dest_w: src_w is src_w { export src_w; }
dest_l: src_l is src_l { export src_l; }

op3_b: src_b is src_b { export src_b; }
op3_w: src_w is src_w { export src_w; }
op3_l: src_l is src_l { export src_l; }

# relative addresses, 8 bit and 16 bit
RelAddr8:  loc is simm8  [ loc = inst_next + simm8; ]        { export *:1 loc; }
RelAddr16: loc is simm16 [ loc = inst_next + simm16; ]       { export *:2 loc; }

# branch

:BR.b RelAddr8 is opcode=0x11; RelAddr8 {
  goto RelAddr8;
}

:BR.w RelAddr16 is opcode=0x31; RelAddr16 {
  goto RelAddr16;
}

# move

:MOV.b src_b, dest_b is opcode=0x90; src_b; dest_b {
  dest_b = src_b;
}

:MOV.w src_w, dest_w is opcode=0xb0; src_w; dest_w {
  dest_w = src_w;
}

:MOV.l src_l, dest_l is opcode=0xd0; src_l; dest_l {
  dest_l = src_l;
}

:MOV.q src_l, dest_l is opcode=0x7d; src_l; dest_l {
  dest_l = src_l;
}

:MOV.o is opcode=0x7d; opcode=0xfd {
  goto 0;
}

# complement

:MCOM.b src_b, dest_b is opcode=0x92; src_b; dest_b {
  dest_b = ~src_b;
}
:MCOM.w src_w, dest_w is opcode=0xb2; src_w; dest_w {
  dest_w = ~src_w;
}
:MCOM.l src_l, dest_l is opcode=0xd2; src_l; dest_l {
  dest_l = src_l ^ -1;
}

# move to processor register
:MFTR src_l, procreg is opcode=0xda; src_l; procreg {
  procreg = src_l;
}

# move from processor register
:MFPR procreg, dest_l is opcode=0xdb; procreg; dest_l {
  dest_l = procreg;
}

# bit clear
:BICB2 src_b, dest_b is opcode=0x8a; src_b; dest_b {
  dest_b = dest_b & ~src_b;
}
:BICW2 src_w, dest_w is opcode=0xaa; src_w; dest_w {
  dest_w = dest_w & ~src_w;
}
:BICL2 src_l, dest_l is opcode=0xca; src_l; dest_l {
  dest_l = dest_l & ~src_l;
}

:BICB3 op3_b, src_b, dest_b is opcode=0x8b; op3_b; src_b; dest_b {
  dest_b = src_b & ~op3_b;
}
:BICW3 op3_w, src_w, dest_w is opcode=0xab; op3_w; src_w; dest_w {
  dest_w = src_w & ~op3_w;
}
:BICL3 op3_l, src_l, dest_l is opcode=0xcb; op3_l; src_l; dest_l {
  dest_l = src_l & ~op3_l;
}
