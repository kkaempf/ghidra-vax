# sleigh specification file for DEC VAX
#
# Copyright (c) 2022 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# condition flags
define register offset=0x50 size=1   [ IS_F CUR_MOD PRV_MOD IPL_F DV_F FU_F IV_F T_F N_F Z_F V_F C_F ];

macro resflags(result) {
 N_F = result s< 0;
 Z_F = result == 0;
}

macro addflags(op1,op2) {
 C_F = carry(op1,op2);
 V_F = scarry(op1,op2);
}

macro addcflags(op1,op2,cf) {
 C_F = carry(op1,op2) || carry(op1+op2, cf);
 V_F = scarry(op1,op2) ^^ scarry(op1+op2, cf);
}

macro subflags(op1,op2) {
 C_F = op1 < op2;
 V_F = sborrow(op1,op2);
}

# processor registers
define register offset=0x100 size=4 [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode  = (0,7)
        op7     = (7,7)
        argsize = (5,6)
        op14    = (1,4)
        op0     = (0,0)
;

# addressing
define token addrmode (8)
        mode67  = (6,7) # literal if mode67 = 0
        litval  = (0,5) # 6-bit literal unsigned
        mode    = (4,7) # mode
        reg     = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor register
define token preg (8)
        procreg = (0,7)
;

attach variables [ procreg ] [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

define register offset=0x1000 size=1  [ contextreg ];
define register offset=0x1004 size=4  [ loc ];

reladdr8: loc is simm8  [ loc = inst_next + simm8; ] { ptr:4 = loc; export ptr; }
reladdr16: loc is simm16  [ loc = inst_next + simm16; ] { ptr:4 = loc; export ptr; }
reladdr32: loc is simm32  [ loc = inst_next + simm32; ] { ptr:4 = loc; export ptr; }


# effective addresses

#  byte
#   0-3: literal
eab: "S^#"^litval is mode67=0 & litval { export *[const]:1 litval; }
#   4: indexed - see below
#   5: register
eab: reg is mode=5 & reg { tmp:1 = reg:1; export tmp; }
#   6: register deferred
eab: (reg) is mode=6 & reg { export *:1 reg; }
#   7: auto decrement
eab: -(reg) is mode=7 & reg { reg = reg - 1; export *:1 reg; }
#   8: auto increment
eab: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 1; export *:1 ptr; }
#   8: immediate mode
eab: "I^#"^simm8 is mode=8 & reg=15; simm8 { loc = inst_next + 1; inst_next = loc; export simm8; } 
#   9: auto increment deferred
eab: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:1 tmp; }
#   9: absolute
eab: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:1 tmp; }
#   10: byte displacement
eab: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:1 ptr; }
#   10: byte relative
eab: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:1 reladdr8; }
#   11: byte displacement deferred
eab: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:1 ptr; }
#   11: byte relative deferred
eab: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:1 ptr; }
#   12: word displacement
eab: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:1 ptr; }
#   12: word relative
eab: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:1 reladdr16; }
#   13: word displacement deferred
eab: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:1 ptr; }
#   13: word relative deferred
eab: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:1 ptr; }
#   14: long displacement
eab: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:1 ptr; }
#   14: long relative
eab: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:1 reladdr32; }
#   15: long displacement deferred
eab: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:1 ptr; }
#   15: long relative deferred
eab: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:1 ptr; }

#  word
eaw: "S^#"^litval is mode67=0 & litval { export *[const]:2 litval; }
eaw: reg is mode=5 & reg { tmp:2 = reg:2; export tmp; }
eaw: (reg) is mode=6 & reg { export *:2 reg; }
eaw: -(reg) is mode=7 & reg { reg = reg - 2; export *:2 reg; }
eaw: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 2; export *:2 ptr; }
eaw: "I^#"^simm16 is mode=8 & reg=15; simm16 { loc = inst_next + 2; inst_next = loc; export simm16; } 
eaw: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:2 tmp; }
eaw: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:2 tmp; }
eaw: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:2 ptr; }
eaw: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:2 reladdr8; }
eaw: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:2 ptr; }
eaw: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:2 ptr; }
eaw: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:2 ptr; }
eaw: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:2 reladdr16; }
eaw: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:2 ptr; }
eaw: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:2 ptr; }
eaw: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:2 ptr; }
eaw: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:2 reladdr32; }
eaw: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:2 ptr; }
eaw: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:2 ptr; }

#  long
eal: "S^#"^litval is mode67=0 & litval { export *[const]:4 litval; }
eal: reg is mode=5 & reg { export reg; }
eal: (reg) is mode=6 & reg { export *reg; }
eal: -(reg) is mode=7 & reg { reg = reg - 4; export *reg; }
eal: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 4; export *ptr; }
eal: "I^#"^simm32 is mode=8 & reg=15; simm32 { loc = inst_next + 4; inst_next = loc; export simm32; } 
eal: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:4 tmp; }
eal: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:4 tmp; }
eal: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:4 ptr; }
eal: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:4 reladdr8; }
eal: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:4 ptr; }
eal: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:4 ptr; }
eal: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:4 ptr; }
eal: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:4 reladdr16; }
eal: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:4 ptr; }
eal: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:4 ptr; }
eal: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:4 ptr; }
eal: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:4 reladdr32; }
eal: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:4 ptr; }
eal: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:4 ptr; }

#  quad
eaq: "S^#"^litval is mode67=0 & litval { export *[const]:8 litval; }
eaq: reg is mode=5 & reg {
  reg1:4 = *[register]:4 (reg+1);
  tmp:8 = zext(reg) + zext(reg1 << 32);
  export tmp;
}
eaq: (reg) is mode=6 & reg { export *:8 reg; }
eaq: -(reg) is mode=7 & reg { reg = reg - 8; export *:8 reg; }
eaq: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 8; export *:8 ptr; }
eaq: "I^#"^simm64 is mode=8 & reg=15; simm64 { loc = inst_next + 8; inst_next = loc; export simm64; } 
eaq: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 8; export *:8 tmp; }
eaq: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:8 ptr; export *:8 tmp; }
eaq: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:8 ptr; }
eaq: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:8 reladdr8; }
eaq: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:8 ptr; }
eaq: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:8 ptr; }
eaq: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:8 ptr; }
eaq: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:8 reladdr16; }
eaq: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:8 ptr; }
eaq: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:8 ptr; }
eaq: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:8 ptr; }
eaq: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:8 reladdr32; }
eaq: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:8 ptr; }
eaq: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:8 ptr; }

#  byte indexed - not sure how to implement this
#base: loc is eal { ptr:4 = loc; export ptr; }
#eab: base(reg) is mode=4 & reg; base { oa = base + 1*reg; export *:1 oa; }
#eaw: base(reg) is mode=4 & reg; base { oa = base + 2*reg; export *:2 oa; }
#eal: base(reg) is mode=4 & reg; base { oa = base + 4*reg; export *:4 oa; }

# readable <size> <anything>
rbx: eab is eab { tmp = eab; export tmp; }
rwx: eaw is eaw { tmp = eaw; export tmp; }
rlx: eal is eal { tmp = eal; export tmp; }

# fixme: ensure writable effective address
mbx: eab is eab { tmp = eab; export tmp; }
mwx: eaw is eaw { tmp = eaw; export tmp; }
mlx: eal is eal { tmp = eal; export tmp; }
mqx: eaq is eaq { tmp = eaq; export tmp; }

:HALT is opcode=0x00 { goto inst_start; }
:NOP is opcode=0x01 { goto inst_next; }

:ADAWI eaw, mwx is opcode=0x58; eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }

:ADDB2 eab, mbx is (op7=1 & argsize=0 & op14=0 & op0=0); eab; mbx { addflags(eab, mbx); tmp = eab + mbx; mbx = tmp; resflags(tmp); }
:ADDB3 eab, rbx, mbx is (op7=1 & argsize=0 & op14=0 & op0=1); eab; rbx; mbx { addflags(eab, rbx); tmp = eab + rbx; mbx = tmp; resflags(tmp); }
:ADDW2 eaw, mwx is (op7=1 & argsize=1 & op14=0 & op0=0); eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }
:ADDW3 eaw, rwx, mwx is (op7=1 & argsize=1 & op14=0 & op0=1); eaw; rwx; mwx { addflags(eaw, rwx); tmp = eaw + rwx; mwx = tmp; resflags(tmp); }
:ADDL2 eal, mlx is (op7=1 & argsize=2 & op14=0 & op0=0); eal; mlx { addflags(eal, mlx); tmp = eal + mlx; mlx = tmp; resflags(tmp); }
:ADDL3 eal, rlx, mlx is (op7=1 & argsize=2 & op14=0 & op0=1); eal; rlx; mlx { addflags(eal, rlx); tmp = eal + rlx; mlx = tmp; resflags(tmp); }

:ADWC eal, mlx is opcode=0xD8; eal; mlx { cf:4 = zext(C_F); addcflags(eal, mlx, cf); tmp = eal + mlx + cf; mlx = tmp; resflags(tmp); }

:ASHL eab, eal, mlx is opcode=0x78; eab; eal; mlx {
  if (eab s> 31) goto <result_zero>;
  if (eab s< 30) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mlx = 0;
  goto <end>;
<shift_left>
  mlx = eal << (eab & 0x1F);
  goto <end>;
<shift_right>
  mlx = eal >> (eab & 0x1F);
  goto <end>;
<result_sign>
  if (eal s> 0) goto <result_zero>;
  mlx = -1;
  goto <end>;
<end>
  resflags(mlx);
  C_F = 0;
}
:ASHQ eab, eaq, mqx is opcode=0x79; eab; eaq; mqx {
  if (eab s> 63) goto <result_zero>;
  if (eab s< 62) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mqx = 0;
  goto <end>;
<shift_left>
  mqx = eaq << (eab & 0x3F);
  goto <end>;
<shift_right>
  mqx = eaq >> (eab & 0x3F);
  goto <end>;
<result_sign>
  if (eaq s> 0) goto <result_zero>;
  mqx = -1;
  goto <end>;
<end>
  resflags(mqx);
  C_F = 0;
}

#:BICB2 eab, mbx is opcode=0x8a & eab & mbx { tmp:1 = mbx & ~(eab); mbx = tmp; resflags(tmp); }
#:BICB3 eab, rbx, mbx is opcode=0x8b & eab & rbx & mbx { }
#:BICW2 eaw, mwx is opcode=0xaa & eaw & mwx { }
#:BICW3 eaw, rwx, mwx is opcode=0xab & eaw & rwx & mwx { }
#:BICL2 eal, mlx is opcode=0xca & eal & mlx { }
#:BICL3 eal, rlx, mlx is opcode=0xcb & eal & rlx & mlx { }
