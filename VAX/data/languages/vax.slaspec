# sleigh specification file for DEC VAX
#
# Copyright (c) 2022 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# condition flags
define register offset=0x50 size=1   [ IS_F CUR_MOD PRV_MOD IPL_F DV_F FU_F IV_F T_F N_F Z_F V_F C_F ];

macro resflags(result) {
 N_F = result s< 0;
 Z_F = result == 0;
}

macro addflags(op1,op2) {
 C_F = carry(op1,op2);
 V_F = scarry(op1,op2);
}

macro addcflags(op1,op2,cf) {
 C_F = carry(op1,op2) || carry(op1+op2, cf);
 V_F = scarry(op1,op2) ^^ scarry(op1+op2, cf);
}

macro subcflags(op1,op2,cf) { # FIXME ?
 C_F = (op1 < op2) || (op1-op2-cf < 0);
 V_F = sborrow(op1,op2) ^^ sborrow(op1-op2, cf);
}

macro subflags(op1,op2) {
 C_F = op1 < op2;
 V_F = sborrow(op1,op2);
}

macro cmpflags(op1,op2) {
 C_F = op1 < op2;
 N_F = op1 s< op2;
 Z_F = op1 == op2;
 V_F = 0;
}

# processor registers
define register offset=0x100 size=4 [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode  = (0,7)
;

# addressing
define token addrmode (8)
        mode67  = (6,7) # literal if mode67 = 0
        litval  = (0,5) # 6-bit literal unsigned
        mode    = (4,7) # mode
        reg     = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor register
define token preg (8)
        procreg = (0,7)
;

attach variables [ procreg ] [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

define register offset=0x1000 size=1  [ contextreg ];
define register offset=0x1004 size=4  [ loc ];

reladdr8: loc is simm8  [ loc = inst_next + simm8; ] { ptr:4 = loc; export ptr; }
reladdr16: loc is simm16  [ loc = inst_next + simm16; ] { ptr:4 = loc; export ptr; }
reladdr32: loc is simm32  [ loc = inst_next + simm32; ] { ptr:4 = loc; export ptr; }


# effective addresses

#  byte
#   0-3: literal
eab: "S^#"^litval is mode67=0 & litval { export *[const]:1 litval; }
#   4: indexed - see below
#   5: register
eab: reg is mode=5 & reg { tmp:1 = reg:1; export tmp; }
#   6: register deferred
eab: (reg) is mode=6 & reg { export *:1 reg; }
#   7: auto decrement
eab: -(reg) is mode=7 & reg { reg = reg - 1; export *:1 reg; }
#   8: auto increment
eab: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 1; export *:1 ptr; }
#   8: immediate mode
eab: "I^#"^simm8 is mode=8 & reg=15; simm8 { loc = inst_next + 1; inst_next = loc; export simm8; } 
#   9: auto increment deferred
eab: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:1 tmp; }
#   9: absolute
eab: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:1 tmp; }
#   10: byte displacement
eab: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:1 ptr; }
#   10: byte relative
eab: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:1 reladdr8; }
#   11: byte displacement deferred
eab: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:1 ptr; }
#   11: byte relative deferred
eab: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:1 ptr; }
#   12: word displacement
eab: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:1 ptr; }
#   12: word relative
eab: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:1 reladdr16; }
#   13: word displacement deferred
eab: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:1 ptr; }
#   13: word relative deferred
eab: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:1 ptr; }
#   14: long displacement
eab: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:1 ptr; }
#   14: long relative
eab: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:1 reladdr32; }
#   15: long displacement deferred
eab: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:1 ptr; }
#   15: long relative deferred
eab: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:1 ptr; }

#  word
eaw: "S^#"^litval is mode67=0 & litval { export *[const]:2 litval; }
eaw: reg is mode=5 & reg { tmp:2 = reg:2; export tmp; }
eaw: (reg) is mode=6 & reg { export *:2 reg; }
eaw: -(reg) is mode=7 & reg { reg = reg - 2; export *:2 reg; }
eaw: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 2; export *:2 ptr; }
eaw: "I^#"^simm16 is mode=8 & reg=15; simm16 { loc = inst_next + 2; inst_next = loc; export simm16; } 
eaw: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:2 tmp; }
eaw: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:2 tmp; }
eaw: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:2 ptr; }
eaw: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:2 reladdr8; }
eaw: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:2 ptr; }
eaw: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:2 ptr; }
eaw: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:2 ptr; }
eaw: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:2 reladdr16; }
eaw: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:2 ptr; }
eaw: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:2 ptr; }
eaw: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:2 ptr; }
eaw: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:2 reladdr32; }
eaw: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:2 ptr; }
eaw: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:2 ptr; }

#  long
eal: "S^#"^litval is mode67=0 & litval { export *[const]:4 litval; }
eal: reg is mode=5 & reg { export reg; }
eal: (reg) is mode=6 & reg { export *reg; }
eal: -(reg) is mode=7 & reg { reg = reg - 4; export *reg; }
eal: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 4; export *ptr; }
eal: "I^#"^simm32 is mode=8 & reg=15; simm32 { loc = inst_next + 4; inst_next = loc; export simm32; } 
eal: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:4 tmp; }
eal: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:4 tmp; }
eal: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:4 ptr; }
eal: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:4 reladdr8; }
eal: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:4 ptr; }
eal: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:4 ptr; }
eal: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:4 ptr; }
eal: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:4 reladdr16; }
eal: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:4 ptr; }
eal: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:4 ptr; }
eal: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:4 ptr; }
eal: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:4 reladdr32; }
eal: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:4 ptr; }
eal: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:4 ptr; }

#  quad
eaq: "S^#"^litval is mode67=0 & litval { export *[const]:8 litval; }
eaq: reg is mode=5 & reg {
  reg1:4 = *[register]:4 (reg+1);
  tmp:8 = zext(reg) + zext(reg1 << 32);
  export tmp;
}
eaq: (reg) is mode=6 & reg { export *:8 reg; }
eaq: -(reg) is mode=7 & reg { reg = reg - 8; export *:8 reg; }
eaq: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 8; export *:8 ptr; }
eaq: "I^#"^simm64 is mode=8 & reg=15; simm64 { loc = inst_next + 8; inst_next = loc; export simm64; } 
eaq: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 8; export *:8 tmp; }
eaq: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:8 ptr; export *:8 tmp; }
eaq: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:8 ptr; }
eaq: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:8 reladdr8; }
eaq: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:8 ptr; }
eaq: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:8 ptr; }
eaq: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:8 ptr; }
eaq: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:8 reladdr16; }
eaq: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:8 ptr; }
eaq: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:8 ptr; }
eaq: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:8 ptr; }
eaq: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:8 reladdr32; }
eaq: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:8 ptr; }
eaq: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:8 ptr; }

#  byte indexed - not sure how to implement this
#base: loc is eal { ptr:4 = loc; export ptr; }
#eab: base(reg) is mode=4 & reg; base { oa = base + 1*reg; export *:1 oa; }
#eaw: base(reg) is mode=4 & reg; base { oa = base + 2*reg; export *:2 oa; }
#eal: base(reg) is mode=4 & reg; base { oa = base + 4*reg; export *:4 oa; }

# readable <size> <anything>
rbx: eab is eab { tmp = eab; export tmp; }
rwx: eaw is eaw { tmp = eaw; export tmp; }
rlx: eal is eal { tmp = eal; export tmp; }
rlx2: eal is eal { tmp = eal; export tmp; }

# fixme: ensure writable effective address
mbx: eab is eab { tmp = eab; export tmp; }
mwx: eaw is eaw { tmp = eaw; export tmp; }
mlx: eal is eal { tmp = eal; export tmp; }
mlx2: eal is eal { tmp = eal; export tmp; }
mqx: eaq is eaq { tmp = eaq; export tmp; }

:HALT is opcode=0x00 { goto inst_start; }
:NOP is opcode=0x01 { goto inst_next; }

:ADAWI eaw, mwx is opcode=0x58; eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }

:ADDB2 eab, mbx is opcode=0x80; eab; mbx { addflags(eab, mbx); tmp = eab + mbx; mbx = tmp; resflags(tmp); }
:ADDB3 eab, rbx, mbx is opcode=0x81; eab; rbx; mbx { addflags(eab, rbx); tmp = eab + rbx; mbx = tmp; resflags(tmp); }
:ADDW2 eaw, mwx is opcode=0xa0; eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }
:ADDW3 eaw, rwx, mwx is opcode=0xa1; eaw; rwx; mwx { addflags(eaw, rwx); tmp = eaw + rwx; mwx = tmp; resflags(tmp); }
:ADDL2 eal, mlx is opcode=0xc0; eal; mlx { addflags(eal, mlx); tmp = eal + mlx; mlx = tmp; resflags(tmp); }
:ADDL3 eal, rlx, mlx is opcode=0xc1; eal; rlx; mlx { addflags(eal, rlx); tmp = eal + rlx; mlx = tmp; resflags(tmp); }

:ADWC eal, mlx is opcode=0xD8; eal; mlx { cf:4 = zext(C_F); addcflags(eal, mlx, cf); tmp = eal + mlx + cf; mlx = tmp; resflags(tmp); }

:ASHL eab, eal, mlx is opcode=0x78; eab; eal; mlx {
  if (eab s> 31) goto <result_zero>;
  if (eab s< 30) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mlx = 0;
  goto <end>;
<shift_left>
  mlx = eal << (eab & 0x1F);
  goto <end>;
<shift_right>
  mlx = eal >> (eab & 0x1F);
  goto <end>;
<result_sign>
  if (eal s> 0) goto <result_zero>;
  mlx = -1;
  goto <end>;
<end>
  resflags(mlx);
  C_F = 0;
}
:ASHQ eab, eaq, mqx is opcode=0x79; eab; eaq; mqx {
  if (eab s> 63) goto <result_zero>;
  if (eab s< 62) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mqx = 0;
  goto <end>;
<shift_left>
  mqx = eaq << (eab & 0x3F);
  goto <end>;
<shift_right>
  mqx = eaq >> (eab & 0x3F);
  goto <end>;
<result_sign>
  if (eaq s> 0) goto <result_zero>;
  mqx = -1;
  goto <end>;
<end>
  resflags(mqx);
  C_F = 0;
}

:BICB2 eab, mbx is opcode=0x8a; eab; mbx { tmp:1 = mbx & ~(eab); mbx = tmp; resflags(tmp); V_F = 0; }
:BICB3 eab, rbx, mbx is opcode=0x8b; eab; rbx; mbx { tmp:1 = rbx & ~(eab); mbx = tmp; resflags(tmp); V_F = 0; }
:BICW2 eaw, mwx is opcode=0xaa; eaw; mwx { tmp:2 = mwx & ~(eaw); mwx = tmp; resflags(tmp); V_F = 0; }
:BICW3 eaw, rwx, mwx is opcode=0xab; eaw; rwx; mwx { tmp:2 = rwx & ~(eaw); mwx = tmp; resflags(tmp); V_F = 0; }
:BICL2 eal, mlx is opcode=0xca; eal; mlx { tmp:4 = mlx & ~(eal); mlx = tmp; resflags(tmp); V_F = 0; }
:BICL3 eal, rlx, mlx is opcode=0xcb; eal; rlx; mlx { tmp:4 = rlx & ~(eal); mlx = tmp; resflags(tmp); V_F = 0; }

:BISB2 eab, mbx is opcode=0x88; eab; mbx { tmp:1 = mbx | eab; mbx = tmp; resflags(tmp); V_F = 0; }
:BISB3 eab, rbx, mbx is opcode=0x89; eab; rbx; mbx { tmp:1 = rbx | eab; mbx = tmp; resflags(tmp); V_F = 0; }
:BISW2 eaw, mwx is opcode=0xa8; eaw; mwx { tmp:2 = mwx | eaw; mwx = tmp; resflags(tmp); V_F = 0; }
:BISW3 eaw, rwx, mwx is opcode=0xa9; eaw; rwx; mwx { tmp:2 = rwx | eaw; mwx = tmp; resflags(tmp); V_F = 0; }
:BISL2 eal, mlx is opcode=0xc8; eal; mlx { tmp:4 = mlx | eal; mlx = tmp; resflags(tmp); V_F = 0; }
:BISL3 eal, rlx, mlx is opcode=0xc9; eal; rlx; mlx { tmp:4 = rlx | eal; mlx = tmp; resflags(tmp); V_F = 0; }

:BIZB2 eab, rbx is opcode=0x93; eab; rbx { tmp:1 = rbx & eab; resflags(tmp); V_F = 0; }
:BITW2 eaw, rwx is opcode=0xb3; eaw; rwx { tmp:2 = rwx & eaw; resflags(tmp); V_F = 0; }
:BITL2 eal, rlx is opcode=0xd3; eal; rlx { tmp:4 = rlx & eal; resflags(tmp); V_F = 0; }

:CLRB eab is opcode=0x94; eab { eab = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRW eaw is opcode=0xb4; eaw { eaw = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRL eal is opcode=0xd4; eal { eal = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRQ eaq is opcode=0x7c; eaq { eaq = 0; N_F = 0; Z_F = 1; V_F = 1; }
#:CLRO eao is opcodew=0x7CFD

:CMPB eab, rbx is opcode=0x91; eab; rbx { cmpflags(eab, rbx); }
:CMPW eaw, rwx is opcode=0xb1; eaw; rwx { cmpflags(eaw, rwx); }
:CMPL eal, rlx is opcode=0xD1; eal; rlx { cmpflags(eal, rlx); }

:CVTBW eab, mwx is opcode=0x99; eab; mwx { tmp:2 = sext(eab); mwx = tmp; resflags(tmp); C_F = 0; }
:CVTBL eab, mlx is opcode=0x98; eab; mlx { tmp:4 = sext(eab); mlx = tmp; resflags(tmp); C_F = 0; }
:CVTWL eaw, mlx is opcode=0x32; eaw; mlx { tmp:4 = sext(eaw); mlx = tmp; resflags(tmp); C_F = 0; }
:CVTWB eaw, mbx is opcode=0x33; eaw; mbx {
  tmp = eaw:1;
  remaining:2 = (eaw & 0xff00);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xff00);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mbx = tmp;
  resflags(tmp);
  C_F = 0;
}
:CVTLB eal, mbx is opcode=0xf6; eal; mbx {
  tmp = eal:1;
  remaining:4 = (eal & 0xffffff00);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xffffff00);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mbx = tmp;
  resflags(tmp);
  C_F = 0;
}
:CVTLW eal, mwx is opcode=0xf7; eal; mwx {
  tmp = eal:2;
  remaining:4 = (eal & 0xffff0000);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xffff0000);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mwx = tmp;
  resflags(tmp);
  C_F = 0;
}

:DECB mbx is opcode=0x97; mbx {
  if (mbx == 0x80) goto <underflow>;
  if (mbx == 0) goto <negative>;
  mbx = mbx - 1;
  goto <end>;
<underflow>
  mbx = 0x7f;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mbx = 0xff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mbx);
}
:DECW mwx is opcode=0xb7; mwx {
  if (mwx == 0x8000) goto <underflow>;
  if (mwx == 0) goto <negative>;
  mwx = mwx - 1;
  goto <end>;
<underflow>
  mwx = 0x7fff;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mwx = 0xffff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mwx);
}
:DECL mlx is opcode=0xd7; mlx {
  if (mlx == 0x80000000) goto <underflow>;
  if (mlx == 0) goto <negative>;
  mlx = mlx - 1;
  goto <end>;
<underflow>
  mlx = 0x7fffffff;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mlx = 0xffffffff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mlx);
}

:DIVB2 eab, mbx is opcode=0x86; eab; mbx { mbx = mbx / eab; C_F = 0; resflags(mbx); } # FIXME V_F
:DIVB3 eab, rbx, mbx is opcode=0x87; eab; rbx; mbx { mbx = rbx / eab; C_F = 0; resflags(mbx); } # FIXME V_F
:DIVW2 eaw, mwx is opcode=0xa6; eaw; mwx { mwx = mwx / eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:DIVW3 eaw, rwx, mwx is opcode=0xa7; eaw; rwx; mwx { mwx = rwx / eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:DIVL2 eal, mlx is opcode=0xc6; eal; mlx { mlx = mlx / eal; C_F = 0; resflags(mlx); } # FIXME V_F
:DIVL3 eal, rlx, mlx is opcode=0xc7; eal; rlx; mlx { mlx = rlx / eal; C_F = 0; resflags(mlx); } # FIXME V_F

:EDIV eal, eaq, mlx, mlx2 is opcode=0x7b; eal; eaq; mlx; mlx2 { divr:8 = sext(eal); quo = eaq / divr; mlx = quo:4; rem = eaq % divr; mlx2 = rem:4; C_F = 0; resflags(mlx); } # FIXME V_F
:EMUL eal, rlx, rlx2, mqx is opcode=0x7a; eal; rlx; rlx2; mqx { mqx = sext(rlx * eal) + sext(rlx2); V_F = 0; C_F = 0; resflags(mqx); }

:INCB mbx is opcode=0x96; mbx {
  if (mbx == 0x7f) goto <overflow>;
  if (mbx == 0xff) goto <positive>;
  mbx = mbx + 1;
  goto <end>;
<overflow>
  mbx = 0x80;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mbx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mbx);
}
:INCW mwx is opcode=0xb6; mwx {
  if (mwx == 0x7fff) goto <overflow>;
  if (mwx == 0xffff) goto <positive>;
  mwx = mwx + 1;
  goto <end>;
<overflow>
  mwx = 0x8000;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mwx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mwx);
}
:INCL mlx is opcode=0xd6; mlx {
  if (mlx == 0x7fffffff) goto <overflow>;
  if (mlx == 0xffffffff) goto <positive>;
  mlx = mlx + 1;
  goto <end>;
<overflow>
  mlx = 0x80000000;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mlx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mlx);
}

:MCOMB eab, mbx is opcode=0x92; eab; mbx { mbx = ~eab; V_F = 0; resflags(mbx); }
:MCOMW eaw, mwx is opcode=0xb2; eaw; mwx { mwx = ~eaw; V_F = 0; resflags(mwx); }
:MCOML eal, mlx is opcode=0xd2; eal; mlx { mlx = ~eal; V_F = 0; resflags(mlx); }

:MNEGB eab, mbx is opcode=0x8e; eab; mbx {
  if (eab == 0x80) goto <overflow>;
  mbx = -eab;
  goto <end>;
<overflow>
  mbx = eab;
<end>
  V_F = 0; resflags(mbx);
}
:MNEGW eaw, mwx is opcode=0xae; eaw; mwx {
  if (eaw == 0x8000) goto <overflow>;
  mwx = -eaw;
  goto <end>;
<overflow>
  mwx = eaw;
<end>
  V_F = 0; resflags(mwx);
}
:MNEGL eal, mlx is opcode=0xce; eal; mlx {
  if (eal == 0x80000000) goto <overflow>;
  mlx = -eal;
  goto <end>;
<overflow>
  mlx = eal;
<end>
  V_F = 0; resflags(mlx);
}

:MOVB eab, mbx is opcode=0x90; eab; mbx { mbx = eab; V_F = 0; resflags(mbx); }
:MOVW eaw, mwx is opcode=0xb0; eaw; mwx { mwx = eaw; V_F = 0; resflags(mwx); }
:MOVL eal, mlx is opcode=0xd0; eal; mlx { mlx = eal; V_F = 0; resflags(mlx); }
:MOVQ eaq, mqx is opcode=0x7d; eaq; mqx { mqx = eaq; V_F = 0; resflags(mqx); }
#:MOVO FIXME

:MOVZBW eab, mwx is opcode=0x9b; eab; mwx { mwx = zext(eab); resflags(mwx); N_F = 0; V_F = 0; }
:MOVZBL eab, mlx is opcode=0x9a; eab; mlx { mlx = zext(eab); resflags(mlx); N_F = 0; V_F = 0; }
:MOVZWL eaw, mlx is opcode=0x3c; eaw; mlx { mlx = zext(eaw); resflags(mlx); N_F = 0; V_F = 0; }

:MULB2 eab, mbx is opcode=0x84; eab; mbx { mbx = mbx * eab; C_F = 0; resflags(mbx); } # FIXME V_F
:MULB3 eab, rbx, mbx is opcode=0x85; eab; rbx; mbx { mbx = rbx * eab; C_F = 0; resflags(mbx); } # FIXME V_F
:MULW2 eaw, mwx is opcode=0xa4; eaw; mwx { mwx = mwx * eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:MULW3 eaw, rwx, mwx is opcode=0xa5; eaw; rwx; mwx { mwx = rwx * eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:MULL2 eal, mlx is opcode=0xc4; eal; mlx { mlx = mlx * eal; C_F = 0; resflags(mlx); } # FIXME V_F
:MULL3 eal, rlx, mlx is opcode=0xc5; eal; rlx; mlx { mlx = rlx * eal; C_F = 0; resflags(mlx); } # FIXME V_F

:PUSHL eal is opcode=0xdd; eal { SP = SP - 4; *:4 SP = eal; V_F = 0; resflags(eal); }

:ROTL eab, eal, mlx is opcode=0x9c; eab; eal; mlx {
  if (eab s> 0) goto <rotate_left>;
  if (eab s< 0) goto <rotate_right>;
  mlx = eal;
  goto <end>;
<rotate_left>
  shifted = eal << eab;
  rot_bits = eal >> (32-eab);
  mlx = shifted | rot_bits;
  goto <end>;
<rotate_right>
  shifted = eal >> eab;
  rot_bits = eal << (32+eab); # eab is negative
  mlx = shifted | rot_bits;
<end>
  V_F = 0;
  resflags(mlx);
}

:SBWC eal, mlx is opcode=0xD9; eal; mlx { cf:4 = zext(C_F); subcflags(eal, mlx, cf); tmp = eal - mlx - cf; mlx = tmp; resflags(tmp); }

:SUBB2 eab, mbx is opcode=0x82; eab; mbx { subflags(eab, mbx); tmp = eab - mbx; mbx = tmp; resflags(tmp); }
:SUBB3 eab, rbx, mbx is opcode=0x83; eab; rbx; mbx { subflags(eab, rbx); tmp = eab - rbx; mbx = tmp; resflags(tmp); }
:SUBW2 eaw, mwx is opcode=0xa2; eaw; mwx { subflags(eaw, mwx); tmp = eaw - mwx; mwx = tmp; resflags(tmp); }
:SUBW3 eaw, rwx, mwx is opcode=0xa3; eaw; rwx; mwx { subflags(eaw, rwx); tmp = eaw - rwx; mwx = tmp; resflags(tmp); }
:SUBL2 eal, mlx is opcode=0xc2; eal; mlx { subflags(eal, mlx); tmp = eal - mlx; mlx = tmp; resflags(tmp); }
:SUBL3 eal, rlx, mlx is opcode=0xc3; eal; rlx; mlx { subflags(eal, rlx); tmp = eal - rlx; mlx = tmp; resflags(tmp); }

:TSTB eab is opcode=0x95; eab { V_F = 0; C_F = 0; resflags(eab); }
:TSTW eaw is opcode=0xb5; eaw { V_F = 0; C_F = 0; resflags(eaw); }
:TSTL eal is opcode=0xd5; eal { V_F = 0; C_F = 0; resflags(eal); }

:XORB2 eab, mbx is opcode=0x8c; eab; mbx { tmp = eab ^ mbx; mbx = tmp; V_F = 0; resflags(tmp); }
:XORB3 eab, rbx, mbx is opcode=0x8d; eab; rbx; mbx { tmp = eab ^ rbx; mbx = tmp; V_F = 0; resflags(tmp); }
:XORW2 eaw, mwx is opcode=0xac; eaw; mwx { tmp = eaw ^ mwx; mwx = tmp; V_F = 0; resflags(tmp); }
:XORW3 eaw, rwx, mwx is opcode=0xad; eaw; rwx; mwx { tmp = eaw ^ rwx; mwx = tmp; V_F = 0; resflags(tmp); }
:XORL2 eal, mlx is opcode=0xcc; eal; mlx { tmp = eal ^ mlx; mlx = tmp; V_F = 0; resflags(tmp); }
:XORL3 eal, rlx, mlx is opcode=0xcd; eal; rlx; mlx { tmp = eal ^ rlx; mlx = tmp; V_F = 0; resflags(tmp); }

