# sleigh specification file for DEC VAX

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
#define register offset=0x40 size=4 [ PSL ];

# processor status word
#define register offset=0x40 size=2 [ _ PSW ];

# status bits within PSW
#define bitrange C=PSW[0,1]
#                V=PSW[1,1]
#                Z=PSW[2,1]
#                N=PSW[3,1]
#                T=PSW[4,1]
#               IV=PSW[5,1]
#               FU=PSW[6,1]
#               DV=PSW[7,1]
#;

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# addressing
define token address (8)
        literal_mode = (6,7) # literal = 0
        literal      = (0,5) # 6-bit literal unsigned
        mode         = (4,7) # mode
        reg          = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# effective addresses

#   long, source

# 0-3: literal
src_l: "S^#"^literal is literal_mode=0 & literal { export literal; }

# 5: register
src_l: reg is mode=5 & reg { export reg; }

# 6: register deferred
src_l: (reg) is mode=6 & reg { ptr:4 = reg; export *:4 ptr; }

# 7: auto decrement
src_l: -(reg) is mode=7 & reg { reg = reg - 4; tmp = reg; export *:4 tmp; }

# immediate
src_l: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
# 8: auto increment
src_l: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

# absolute
src_l: "@#"^imm32 is mode=9 & reg=15; imm32 { export imm32; }
# 9: auto increment deferred
src_l: @(reg)+ is mode=9 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

#   long, dest

dest_l: ""^src_l is src_l { export src_l; }

#   byte

# 0-3: literal
#eab: "S^#"^literal is literal_mode=0 & literal { export *:1 literal; }
# 5: register
#eab: reg is mode=5 & reg { export *:1 reg; }
# immediate
#eab: "I^#"^data32 is mode=8 & reg=PC; simm8 { export *:1 simm8; } 

# opcode
define token opbyte (8)
        opcode = (0,7)
;

# relative addresses, 8 bit and 16 bit
RelAddr8:  loc is simm8  [ loc = inst_next + simm8; ]        { export *:1 loc; }
RelAddr16: loc is simm16 [ loc = inst_next + simm16; ]       { export *:2 loc; }

# branch

# 0001_0001
:BR.b RelAddr8 is opcode=0x11; RelAddr8 {
  goto RelAddr8;
}

# 0011_0001
:BR.w RelAddr16 is opcode=0x31; RelAddr16 {
  goto RelAddr16;
}

# 1001_0000
#:MOV.b src_b, dest_b is opcode=0x90; src_b; dest_b {
#  dest_b = src_b;
#}
# 1011_0000
#:MOV.w src_w, dest_w is opcode=0xb0; src_w; dest_w {
#  dest_w = src_w;
#}

# 1101_0000
:MOV.l src_l, dest_l is opcode=0xd0; src_l; dest_l {
  dest_l = src_l;
}

# 0111_1101
:MOV.q src_l, dest_l is opcode=0x7d; src_l; dest_l {
  dest_l = src_l;
}

:MOV.o is opcode=0x7d; opcode=0xfd {
  goto 0;
}

:MCOM.l src_l, dest_l is opcode=0xd2; src_l; dest_l {
  dest_l = src_l ^ -1;
}
