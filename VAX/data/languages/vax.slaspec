# sleigh specification file for DEC VAX
#
# Copyright (c) 2022 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# processor registers
define register offset=0x100 size=4 [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

# status bits within PSW
@define C  "PSW[0,1]" # Carry
@define V  "PSW[1,1]" # Overflow
@define Z  "PSW[2,1]" # Zero
@define N  "PSW[3,1]" # Negative
@define T  "PSW[4,1]" # Trace enable
@define IV "PSW[5,1]" # integer overflow enable
@define FU "PSW[6,1]" # floating underflow enable
@define DV "PSW[7,1]" # decimal overflow enable

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode = (0,7)
;

# addressing
define token addrmode (8)
        mode67  = (6,7) # literal if mode67 = 0
        litval  = (0,5) # 6-bit literal unsigned
        mode    = (4,7) # mode
        reg     = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor register
define token preg (8)
        procreg = (0,7)
;

attach variables [ procreg ] [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

# effective addresses

# 0-3: literal
src_b: "S^#"^litval is mode67=0 & litval { export *[const]:1 litval; }
src_w: "S^#"^litval is mode67=0 & litval { export *[const]:2 litval; }
src_l: "S^#"^litval is mode67=0 & litval { export *[const]:4 litval; }

# 4: indexed
#src_l: src_l[reg] is mode=4 & reg & src_l { tmp:4 = reg + src_l; export tmp; }

# 5: register
src_b: reg is mode=5 & reg { tmp:1 = reg:1; export tmp; }
src_w: reg is mode=5 & reg { tmp:2 = reg:2; export tmp; }
src_l: reg is mode=5 & reg { export reg; }

# 6: register deferred
src_b: (reg) is mode=6 & reg { export *:1 reg; }
src_w: (reg) is mode=6 & reg { export *:2 reg; }
src_l: (reg) is mode=6 & reg { export *reg; }

# 7x: auto decrement
src_b: -(reg) is mode=7 & reg { reg = reg - 1; export *:1 reg; }
src_w: -(reg) is mode=7 & reg { reg = reg - 2; export *:2 reg; }
src_l: -(reg) is mode=7 & reg { reg = reg - 4; export *reg; }

# 8f immediate
src_b: "I^#"^simm32 is mode=8 & reg=15; simm32 { tmp:1 = simm32; export tmp; } 
# 8x: auto increment
src_b: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 1; export *:1 tmp; }
src_w: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; }
src_w: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 2; export *:2 tmp; }
src_l: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; }
src_l: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }
                
# 9f: absolute
src_b: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:1 tmp; }
src_w: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:2 tmp; }
src_l: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:4 tmp; }
# 9x: auto increment deferred
src_b: @(reg)+ is mode=9 & reg { tmp = *:4 reg; reg = reg + 4; export *:1 tmp; }
src_w: @(reg)+ is mode=9 & reg { tmp = *:4 reg; reg = reg + 4; export *:2 tmp; }
src_l: @(reg)+ is mode=9 & reg { tmp = *:4 reg; reg = reg + 4; export *:4 tmp; }

offset_b: "B^"^simm8 is simm8 { export *[const]:1 simm8; }

# af: byte relative
# ax: byte displacement
src_b: offset_b(reg) is mode=10 & reg; offset_b { ptr = reg + sext(offset_b); export *:1 ptr; }
src_w: offset_b(reg) is mode=10 & reg; offset_b { ptr = reg + sext(offset_b); export *:2 ptr; }
src_l: offset_b(reg) is mode=10 & reg; offset_b { ptr = reg + sext(offset_b); export *:4 ptr; }

# bf: byte relative deferred
# bx: byte displacement deferred
src_b: "@B^"^simm8(reg) is mode=11 & reg; simm8 { tmp = reg + simm8; ptr = *:4 tmp; export *:1 ptr; }
src_w: "@B^"^simm8(reg) is mode=11 & reg; simm8 { tmp = reg + simm8; ptr = *:4 tmp; export *:2 ptr; }
src_l: "@B^"^simm8(reg) is mode=11 & reg; simm8 { tmp = reg + simm8; ptr = *:4 tmp; export *:4 ptr; }

# cf: word relative
# cx: word displacement
src_b: "W^"^simm16(reg) is mode=12 & reg; simm16 { tmp = reg + simm16; export *:1 tmp; }
src_w: "W^"^simm16(reg) is mode=12 & reg; simm16 { tmp = reg + simm16; export *:2 tmp; }
src_l: "W^"^simm16(reg) is mode=12 & reg; simm16 { tmp = reg + simm16; export *:4 tmp; }

# df: word relative deferred
# dx: word displacement deferred
src_b: "@W^"^simm16(reg) is mode=13 & reg; simm16 { tmp = reg + simm16; ptr = *:4 tmp; export *:1 ptr; }
src_w: "@W^"^simm16(reg) is mode=13 & reg; simm16 { tmp = reg + simm16; ptr = *:4 tmp; export *:2 ptr; }
src_l: "@W^"^simm16(reg) is mode=13 & reg; simm16 { tmp = reg + simm16; ptr = *:4 tmp; export *:4 ptr; }

# ef: longword relative
# ex: longword displacement
src_b: "L^"^simm32(reg) is mode=14 & reg; simm32 { tmp = reg + simm32; export *:1 tmp; }
src_w: "L^"^simm32(reg) is mode=14 & reg; simm32 { tmp = reg + simm32; export *:2 tmp; }
src_l: "L^"^simm32(reg) is mode=14 & reg; simm32 { tmp = reg + simm32; export *:4 tmp; }

# ff: longword relative deferred
# fx: longword displacement deferred
src_b: "@L^"^simm32(reg) is mode=15 & reg; simm32 { tmp = reg + simm32; ptr = *:4 tmp; export *:1 ptr; }
src_w: "@L^"^simm32(reg) is mode=15 & reg; simm32 { tmp = reg + simm32; ptr = *:4 tmp; export *:2 ptr; }
src_l: "@L^"^simm32(reg) is mode=15 & reg; simm32 { tmp = reg + simm32; ptr = *:4 tmp; export *:4 ptr; }

#   dest

dest_b: src_b is src_b { export src_b; }
dest_w: src_w is src_w { export src_w; }
dest_l: src_l is src_l { export src_l; }

op3_b: src_b is src_b { export src_b; }
op3_w: src_w is src_w { export src_w; }
op3_l: src_l is src_l { export src_l; }

# relative addresses, 8 bit and 16 bit
RelAddr8:  loc is simm8  [ loc = inst_next + simm8; ]        { export *:1 loc; }
RelAddr16: loc is simm16 [ loc = inst_next + simm16; ]       { export *:2 loc; }

# halt

:HALT is opcode=0x0 {
  goto inst_start;
}

# branch

# 0001 0001
:BR.b RelAddr8 is opcode=0x11; RelAddr8 {
  goto RelAddr8;
}
# 0001 0010
:BNEQ RelAddr8 is opcode=0x12; RelAddr8 {
  if ($(Z) == 0) goto RelAddr8;
}
# 0001 0011
:BEQL RelAddr8 is opcode=0x13; RelAddr8 {
  if ($(Z) == 1) goto RelAddr8;
}
# 0001 0100
:BGTR RelAddr8 is opcode=0x14; RelAddr8 {
  if (($(Z)|$(N)) == 0) goto RelAddr8;
}
# 0001 0101
:BLEQ RelAddr8 is opcode=0x15; RelAddr8 {
  if (($(Z)|$(N)) == 1) goto RelAddr8;
}
# 0001 0110 -
# 0001 0111 -
# 0001 1000
:BGEQ RelAddr8 is opcode=0x18; RelAddr8 {
  if ($(N) == 0) goto RelAddr8;
}
# 0001 1001
:BLSS RelAddr8 is opcode=0x19; RelAddr8 {
  if ($(N) == 1) goto RelAddr8;
}
# 0001 1010
:BGTRU RelAddr8 is opcode=0x1a; RelAddr8 {
  if (($(C)|$(Z)) == 0) goto RelAddr8;
}
# 0001 1011
:BLEQU RelAddr8 is opcode=0x1b; RelAddr8 {
  if (($(C)|$(Z)) == 1) goto RelAddr8;
}
# 0001 1100
:BVC RelAddr8 is opcode=0x1c; RelAddr8 {
  if ($(V) == 0) goto RelAddr8;
}
# 0001 1101
:BVS RelAddr8 is opcode=0x1d; RelAddr8 {
  if ($(V) == 1) goto RelAddr8;
}
# 0001 1110
:BCC RelAddr8 is opcode=0x1e; RelAddr8 {
  if ($(C) == 0) goto RelAddr8;
}
# 0001 1111
:BCS RelAddr8 is opcode=0x1f; RelAddr8 {
  if ($(C) == 1) goto RelAddr8;
}
:BR.w RelAddr16 is opcode=0x31; RelAddr16 {
  goto RelAddr16;
}


# move

:MOV.b src_b, dest_b is opcode=0x90; src_b; dest_b {
  dest_b = src_b;
}

:MOV.w src_w, dest_w is opcode=0xb0; src_w; dest_w {
  dest_w = src_w;
}

:MOV.l src_l, dest_l is opcode=0xd0; src_l; dest_l {
  dest_l = src_l;
}

:MOV.q src_l, dest_l is opcode=0x7d; src_l; dest_l {
  dest_l = src_l;
}

:MOV.o is opcode=0x7d; opcode=0xfd {
  goto 0;
}

# complement

:MCOM.b src_b, dest_b is opcode=0x92; src_b; dest_b {
  dest_b = ~src_b;
}
:MCOM.w src_w, dest_w is opcode=0xb2; src_w; dest_w {
  dest_w = ~src_w;
}
:MCOM.l src_l, dest_l is opcode=0xd2; src_l; dest_l {
  dest_l = src_l ^ -1;
}

# move to processor register
:MFTR src_l, procreg is opcode=0xda; src_l; procreg {
  procreg = src_l;
}

# move from processor register
:MFPR procreg, dest_l is opcode=0xdb; procreg; dest_l {
  dest_l = procreg;
}

# bit clear

:BICB2 src_b, dest_b is opcode=0x8a; src_b; dest_b {
  dest_b = dest_b & ~src_b;
}
:BICW2 src_w, dest_w is opcode=0xaa; src_w; dest_w {
  dest_w = dest_w & ~src_w;
}
:BICL2 src_l, dest_l is opcode=0xca; src_l; dest_l {
  dest_l = dest_l & ~src_l;
}

:BICB3 op3_b, src_b, dest_b is opcode=0x8b; op3_b; src_b; dest_b {
  dest_b = src_b & ~op3_b;
}
:BICW3 op3_w, src_w, dest_w is opcode=0xab; op3_w; src_w; dest_w {
  dest_w = src_w & ~op3_w;
}
:BICL3 op3_l, src_l, dest_l is opcode=0xcb; op3_l; src_l; dest_l {
  dest_l = src_l & ~op3_l;
}

# compare

macro negflag(a,b)
{
  $(N) = (sext(a) s< sext(b));
}

macro zeroflag(a,b)
{
  $(Z) = (a == b);
}

macro carryflag(a,b)
{
  $(C) = (zext(a) < zext(b));
}

:CMPB src_b, dest_b is opcode=0x91; src_b; dest_b {
#  negflag(src_b, dest_b);
  zeroflag(src_b, dest_b);
  $(V) = 0;
#  carryflag(src_b, dest_b);
}

:CMPW src_w, dest_w is opcode=0xb1; src_w; dest_w {
#  negflag(src_w, dest_w);
  zeroflag(src_w, dest_w);
  $(V) = 0;
#  carryflag(src_w, dest_w);
}
:CMPL src_l, dest_l is opcode=0xd1; src_l; dest_l {
#  negflag(src_l, dest_l);
  zeroflag(src_l, dest_l);
  $(V) = 0;
#  carryflag(src_l, dest_l);
}

# compare field
pos: src_l is src_l { export src_l; }
size.rb: src_b is src_b { export src_b; }
base: src_l is src_l { export src_l; }

:CMPV pos, size.rb, base, src_l is opcode=0xec; pos; size.rb; base; src_l {
  field = base + pos*sext(size.rb);
}
:CMPZV pos, size.rb, base, src_l is opcode=0xed; pos; size.rb; base; src_l {
  field = base + pos*zext(size.rb); # TODO zext
}

# case
selector.b: src_b is src_b { export src_b; }
limit.b: src_b is src_b { export src_b; }
selector.w: src_w is src_w { export src_w; }
limit.w: src_w is src_w { export src_w; }
selector.l: src_l is src_l { export src_l; }
limit.l: src_l is src_l { export src_l; }

:CASE.b selector.b, base, limit.b is opcode=0x8f; selector.b; base; limit.b {
  offset = 2*(limit.b + 1);
  loc = inst_next + offset;
  goto [loc];
}
:CASE.w selector.w, base, limit.w is opcode=0xaf; selector.w; base; limit.w {
  offset = 2*(limit.w + 1);
  loc = inst_next + offset;
  goto [loc];
}
:CASE.l selector.l, base, limit.l is opcode=0xcf; selector.l; base; limit.l {
  offset = 2*(limit.l + 1);
  loc = inst_next + offset;
  goto [loc];
}

# Subtract one and branch
#  if greater than or equal
:SOBGEQ dest_l, RelAddr8 is opcode=0xf4; dest_l; RelAddr8 {
  dest_l = dest_l - 1;
  if (dest_l >= 0) goto RelAddr8;
}
#  if greater than
:SOBGTR dest_l, RelAddr8 is opcode=0xf5; dest_l; RelAddr8 {
  dest_l = dest_l - 1;
  if (dest_l > 0) goto RelAddr8;
}

# jump

:JMP src_l is opcode=0x17; src_l {
  goto src_l;
}

# insert field
pos_l: src_l is src_l { export src_l; }
size_b: src_b is src_b { export src_b; }
base_b: src_b is src_b { export src_b; }
:INSV src_l, pos_l, size_b, base_b is opcode=0xf0; src_l; pos_l; size_b; base_b {
}

# branch bit set/clear

:BBS pos_l, base_b, RelAddr8 is opcode=0xE0; pos_l; base_b; RelAddr8 {
  goto RelAddr8;
}
:BBC pos_l, base_b, RelAddr8 is opcode=0xE1; pos_l; base_b; RelAddr8 {
  goto RelAddr8;
}

# move zero-extended
#   byte to word
:MOVZBW src_b, dest_w is opcode=0x9b; src_b; dest_w {
  dest_w = zext(src_b);
}
#   byte to long
:MOVZBW src_b, dest_l is opcode=0x9a; src_b; dest_l {
  dest_l = zext(src_b);
}
#   word to long
:MOVZWL src_w, dest_l is opcode=0x3c; src_w; dest_l {
  dest_l = zext(src_w);
}

# Extract field
:EXTV pos_l, size_b, base_b, dest_l is opcode=0xee; pos_l; size_b; base_b; dest_l {
}
#  extract zero-extended field
:EXTZV pos_l, size_b, base_b, dest_l is opcode=0xef; pos_l; size_b; base_b; dest_l {
}

# move address
:MOVA.b src_b; dest_l is opcode=0x9e; src_b; dest_l {
  dest_l = sext(src_b);
}
:MOVA.w src_w; dest_l is opcode=0x3e; src_w; dest_l {
  dest_l = sext(src_w);
}
:MOVA.l src_l; dest_l is opcode=0xde; src_l; dest_l {
  dest_l = src_l;
}
:MOVA.q src_l; dest_l is opcode=0x7e; src_l; dest_l {
  dest_l = src_l;
}

# subtract
min_b: src_b is src_b { export src_b; }
min_w: src_w is src_w { export src_w; }
min_l: src_l is src_l { export src_l; }

:SUBB2 src_b, dest_b is opcode=0x82; src_b; dest_b {
  dest_b = dest_b - src_b;
}
:SUBB3 src_b, min_b, dest_b is opcode=0x83; src_b; min_b; dest_b {
  dest_b = min_b - src_b;
}
:SUBW2 src_w, dest_w is opcode=0xA2; src_w; dest_w {
  dest_w = dest_w - src_w;
}
:SUBW3 src_w, min_w, dest_w is opcode=0xA3; src_w; min_w; dest_w {
  dest_w = min_w - src_w;
}
:SUBL2 src_l, dest_l is opcode=0xC2; src_l; dest_l {
  dest_l = dest_l - src_l;
}
:SUBL3 src_l, min_l, dest_l is opcode=0xC3; src_l; min_l; dest_l {
  dest_l = min_l - src_l;
}
