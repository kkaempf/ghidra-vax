# sleigh specification file for DEC VAX

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;

define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# processor registers
define register offset=0x100 size=4 [ KSP   ESP  SSP  USP    ISP  
                                      P0BR  P0LR P1BR P1LR   SBR  SLR  CPUID
                                      PCBB  SCBB IPL  ASTLVL SIRR SISR
                                      ICCS  NICR ICR  TODR
                                      RXCS  RXDB TXCS TXDB
                                      x2a x2b
                                      MAPEN TBIA TBIS             PME  SID TBCHK
                                      VPSR  VAER VMAC VTBIA  VSAR ];

# status bits within PSW
#define bitrange C=PSW[0,1]
#                V=PSW[1,1]
#                Z=PSW[2,1]
#                N=PSW[3,1]
#                T=PSW[4,1]
#               IV=PSW[5,1]
#               FU=PSW[6,1]
#               DV=PSW[7,1]
#;

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (64)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode = (0,7)
;

# addressing
define token addrmode (8)
        literal_mode = (6,7) # literal = 0
        literal      = (0,5) # 6-bit literal unsigned
        mode         = (4,7) # mode
        reg          = (0,3) # register
;

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor register
define token preg (8)
        procreg = (0,7)
;

attach variables [ procreg ] [ KSP   ESP  SSP  USP    ISP  _    _     _   #  0 -
                               P0BR  P0LR P1BR P1LR   SBR  SLR  CPUID _   #  8 -
                               PCBB  SCBB IPL  ASTLVL SIRR SISR _     _   # 16 -
                               ICCS  NICR ICR  TODR   _    _    _     _   # 24 -
                               RXCS  RXDB TXCS TXDB   _    _    _     _   # 32 -
                               _     _    x2a  x2b    _    _    _     _   # 40 -
                               _     _    _    _      _    _    _     _   # 48 -
                               MAPEN TBIA TBIS _      _    PME  SID TBCHK # 56 -
                               _     _    _    _      _    _    _     _   # 64
                               _     _    _    _      _    _    _     _   # 72
                               _     _    _    _      _    _    _     _   # 80
                               _     _    _    _      _    _    _     _   # 88
                               _     _    _    _      _    _    _     _   # 96
                               _     _    _    _      _    _    _     _   # 104
                               _     _    _    _      _    _    _     _   # 112
                               _     _    _    _      _    _    _     _   # 120
                               _     _    _    _      _    _    _     _   # 128
                               _     _    _    _      _    _    _     _   # 136
                               VPSR  VAER VMAC VTBIA  VSAR _    _     _   # 144
                               _     _    _    _      _    _    _     _   # 152
                               _     _    _    _      _    _    _     _   # 160
                               _     _    _    _      _    _    _     _   # 168
                               _     _    _    _      _    _    _     _   # 176
                               _     _    _    _      _    _    _     _   # 184
                               _     _    _    _      _    _    _     _   # 192
                               _     _    _    _      _    _    _     _   # 200
                               _     _    _    _      _    _    _     _   # 208
                               _     _    _    _      _    _    _     _   # 216
                               _     _    _    _      _    _    _     _   # 224
                               _     _    _    _      _    _    _     _   # 232
                               _     _    _    _      _    _    _     _   # 240
                               _     _    _    _      _    _    _     _   # 248
                               ];

# effective addresses

#   long, source

# 0-3: literal
src_l: "S^#"^literal is literal_mode=0 & literal { export literal; }

# 5: register
src_l: reg is mode=5 & reg { export reg; }

# 6: register deferred
src_l: (reg) is mode=6 & reg { ptr:4 = reg; export *:4 ptr; }

# 7: auto decrement
src_l: -(reg) is mode=7 & reg { reg = reg - 4; tmp = reg; export *:4 tmp; }

# immediate
src_l: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
# 8: auto increment
src_l: (reg)+ is mode=8 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

# absolute
src_l: "@#"^imm32 is mode=9 & reg=15; imm32 { export imm32; }
# 9: auto increment deferred
src_l: @(reg)+ is mode=9 & reg { tmp = reg; reg = reg + 4; export *:4 tmp; }

# byte relative
#src_l: "B^"^simm8^"(PC)" is mode=10 & reg=15; simm8 { tmp = inst_next + simm8; export *:4 tmp; }
# byte displacement
src_l: "B^"^simm8(reg) is mode=10 & reg; simm8 { tmp = reg + simm8; export *:4 tmp; }

# byte relative deferred
#src_l: "@B^"^simm8^"(PC)" is mode=11 & reg=15; simm8 { tmp = inst_next + simm8; export *:4 tmp; }
# byte displacement deferred
src_l: "@B^"^simm8(reg) is mode=11 & reg; simm8 { tmp = reg + simm8; export *:4 tmp; }

# word relative
#src_l: "W^"^simm16^"(PC)" is mode=12 & reg=15; simm16 { tmp = inst_next + simm16; export *:4 tmp; }
# word displacement
src_l: "W^"^simm16(reg) is mode=12 & reg; simm16 { tmp = reg + simm16; export *:4 tmp; }

# word relative deferred
#src_l: "@W^"^simm16^"(PC)" is mode=13 & reg=15; simm16 { tmp = inst_next + simm16; export *:4 tmp; }
# word displacement deferred
src_l: "@W^"^simm16(reg) is mode=13 & reg; simm16 { tmp = reg + simm16; export *:4 tmp; }

# longword relative
#src_l: "L^"^simm32^"(PC)" is mode=14 & reg=15; simm32 { tmp = inst_next + simm32; export *:4 tmp; }
# longword displacement
src_l: "L^"^simm32(reg) is mode=14 & reg; simm32 { tmp = reg + simm32; export *:4 tmp; }

# longword relative deferred
#src_l: "@L^"^simm32^"(PC)" is mode=15 & reg=15; simm32 { tmp = inst_next + simm32; export *:4 tmp; }
# longword displacement deferred
src_l: "@L^"^simm32(reg) is mode=15 & reg; simm32 { tmp = reg + simm32; export *:4 tmp; }

#   long, dest

dest_l: ""^src_l is src_l { export src_l; }

#   byte

# 0-3: literal
#eab: "S^#"^literal is literal_mode=0 & literal { export *:1 literal; }
# 5: register
#eab: reg is mode=5 & reg { export *:1 reg; }
# immediate
#eab: "I^#"^data32 is mode=8 & reg=PC; simm8 { export *:1 simm8; } 

# relative addresses, 8 bit and 16 bit
RelAddr8:  loc is simm8  [ loc = inst_next + simm8; ]        { export *:1 loc; }
RelAddr16: loc is simm16 [ loc = inst_next + simm16; ]       { export *:2 loc; }

# branch

# 0001_0001
:BR.b RelAddr8 is opcode=0x11; RelAddr8 {
  goto RelAddr8;
}

# 0011_0001
:BR.w RelAddr16 is opcode=0x31; RelAddr16 {
  goto RelAddr16;
}

# 1001_0000
#:MOV.b src_b, dest_b is opcode=0x90; src_b; dest_b {
#  dest_b = src_b;
#}
# 1011_0000
#:MOV.w src_w, dest_w is opcode=0xb0; src_w; dest_w {
#  dest_w = src_w;
#}

# 1101_0000
:MOV.l src_l, dest_l is opcode=0xd0; src_l; dest_l {
  dest_l = src_l;
}

# 0111_1101
:MOV.q src_l, dest_l is opcode=0x7d; src_l; dest_l {
  dest_l = src_l;
}

:MOV.o is opcode=0x7d; opcode=0xfd {
  goto 0;
}

:MCOM.l src_l, dest_l is opcode=0xd2; src_l; dest_l {
  dest_l = src_l ^ -1;
}

# move to processor register
:MFTR src_l, procreg is opcode=0xda; src_l; procreg {
  procreg = src_l;
}

# move from processor register
:MFPR procreg, dest_l is opcode=0xdb; procreg; dest_l {
  dest_l = procreg;
}

:BICL2 src_l, dest_l is opcode=0xca; src_l; dest_l {
  dest_l = dest_l & ~src_l;
}

#:BICL3 imm32, src_l, dest_l is opcode=0xcb; imm32; src_l; dest_l {
#  dest_l = src_l & ~imm32;
#}
