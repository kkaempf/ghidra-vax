# sleigh specification file for DEC VAX
#
# Copyright (c) 2022 by Klaus KÃ¤mpf <kkaempf@gmail.com>
#
# Licensed under the Apache 2.0 license
#


#--------------------------------------------------------------------------
# Spaces

define endian=little;
define alignment=1;
define space ram      type=ram_space      size=4  wordsize=1 default;
define space register type=register_space size=4;


#--------------------------------------------------------------------------
# Registers
                                     #0  4  8  c 10 14 18 1c 20 24  28  2c 30 34 38 3c 
define register offset=0x00 size=4 [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

# processor status longword
define register offset=0x40 size=4 [ PSL ];

# processor status word
define register offset=0x40 size=2 [ _ PSW ];

# condition flags
define register offset=0x50 size=1   [ IS_F CUR_MOD PRV_MOD IPL_F DV_F FU_F IV_F T_F N_F Z_F V_F C_F ];

# processor registers
define register offset=0x100 size=4 [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];

define register offset=0x500 size=4  [ loc ];

#--------------------------------------------------------------------------
# Macros

macro resflags(result) {
 N_F = result s< 0;
 Z_F = result == 0;
}

macro resfflags(result) {
 N_F = result f< 0;
 Z_F = result f== 0;
}

macro addflags(op1,op2) {
 C_F = carry(op1,op2);
 V_F = scarry(op1,op2);
}

macro addcflags(op1,op2,cf) {
 C_F = carry(op1,op2) || carry(op1+op2, cf);
 V_F = scarry(op1,op2) ^^ scarry(op1+op2, cf);
}

macro subcflags(op1,op2,cf) { # FIXME ?
 C_F = (op1 < op2) || (op1-op2-cf s< 0);
 V_F = sborrow(op1,op2) ^^ sborrow(op1-op2, cf);
}

macro subflags(op1,op2) {
 C_F = op1 < op2;
 V_F = sborrow(op1,op2);
}

macro cmpflags(op1,op2) {
 C_F = op1 < op2;
 N_F = op1 s< op2;
 Z_F = op1 == op2;
 V_F = 0;
}

macro cmpfflags(op1,op2) {
 N_F = op1 f< op2;
 Z_F = op1 f== op2;
 V_F = 0;
 C_F = 0;
}

macro set_field(f, pos, sz, addr) {
  ptr:4 = addr + sext(pos[29,3]);
  pos20 = pos[0,2];
  highest_bit = (sz-1) + pos20;
  lowest_bit = highest_bit - sz - 1;
  f = *:4 ptr;
  f = f << highest_bit; # move higher bits out
  f = f >> 32-lowest_bit; # move bits down
}

macro push(val) {
  SP = SP - 4;
  *:4 SP = val;
}

macro pop(ret) {
  ret = *:4 SP;
  SP = SP + 4;
}


#--------------------------------------------------------------------------
# Tokens

# 8bit immediate - byte
define token byte (8)
        imm8  = (0,7)
        sign8 = (7,7)
        simm8 = (0,7) signed
;

# 16bit immediate - word
define token word (16)
        imm16  = ( 0,15)
        sign16 = (15,15)
        simm16 = ( 0,15) signed
;

# 32bit immediate - long
define token long (32)
        imm32  = ( 0,31)
        sign32 = (31,31)
        simm32 = ( 0,31) signed
;

# 64bit immediate - quad
define token quad (64)
        imm64  = ( 0,63)
        sign64 = (63,63)
        simm64 = ( 0,63) signed
;

# 128bit immediate - octa
define token octa (128)
        imm128  = (  0,127)
        sign128 = (127,127)
        simm128 = (  0,127) signed
;

# opcode
define token opbyte (8)
        opcode  = (0,7)
        lownibble = (0,3)
        highnibble = (4,7)
;

# addressing
define token addrmode (8)
        mode67  = (6,7) # literal if mode67 = 0
        litval  = (0,5) # 6-bit literal unsigned
        mode    = (4,7) # mode
        reg     = (0,3) # register
;

# processor register
define token preg (8)
        procreg = (0,7)
;


#--------------------------------------------------------------------------
# Variables

attach variables [ reg ] [ R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 AP FP SP PC ];

attach variables [ procreg ] [ KSP   ESP   SSP   USP   ISP   PRx05 PRx06 PRx07
                               P0BR  P0LR  P1BR  P1LR  SBR   SLR   CPUID PRx0f
                               PCBB  SCBB  IPL   ASTLVL SIRR SISR  PRx16 PRx17
                               ICCS  NICR  ICR   TODR  PRx1c PRx1d PRx1e PRx1f
                               RXCS  RXDB  TXCS  TXDB  PRx24 PRx25 PRx26 PRx27
                               PRx28 PRx29 PRx2a PRx2b PRx2c PRx2d PRx2e PRx2f
                               PRx30 PRx31 PRx32 PRx33 PRx34 PRx35 PRx36 PRx37
                               MAPEN TBIA  TBIS  PRx3b PRx3c PME   SID   TBCHK
                               PRx40 PRx41 PRx42 PRx43 PRx44 PRx45 PRx46 PRx47
                               PRx48 PRx49 PRx4a PRx4b PRx4c PRx4d PRx4e PRx4f
                               PRx50 PRx51 PRx52 PRx53 PRx54 PRx55 PRx56 PRx57
                               PRx58 PRx59 PRx5a PRx5b PRx5c PRx5d PRx5e PRx5f
                               PRx60 PRx61 PRx62 PRx63 PRx64 PRx65 PRx66 PRx67
                               PRx68 PRx69 PRx6a PRx6b PRx6c PRx6d PRx6e PRx6f
                               PRx70 PRx71 PRx72 PRx73 PRx74 PRx75 PRx76 PRx77
                               PRx78 PRx79 PRx7a PRx7b PRx7c PRx7d PRx7e PRx7f
                               PRx80 PRx81 PRx82 PRx83 PRx84 PRx85 PRx86 PRx87
                               PRx88 PRx89 PRx8a PRx8b PRx8c PRx8d PRx8e PRx8f
                               VPSR  VAER  VMAC  VTBIA VSAR  PRx95 PRx96 PRx97
                               PRx98 PRx99 PRx9a PRx9b PRx9c PRx9d PRx9e PRx9f
                               PRxa0 PRxa1 PRxa2 PRxa3 PRxa4 PRxa5 PRxa6 PRxa7
                               PRxa8 PRxa9 PRxaa PRxab PRxac PRxad PRxae PRxaf
                               PRxb0 PRxb1 PRxb2 PRxb3 PRxb4 PRxb5 PRxb6 PRxb7
                               PRxb8 PRxb9 PRxba PRxbb PRxbc PRxbd PRxbe PRxbf
                               PRxc0 PRxc1 PRxc2 PRxc3 PRxc4 PRxc5 PRxc6 PRxc7
                               PRxc8 PRxc9 PRxca PRxcb PRxcc PRxcd PRxce PRxcf
                               PRxd0 PRxd1 PRxd2 PRxd3 PRxd4 PRxd5 PRxd6 PRxd7
                               PRxd8 PRxd9 PRxda PRxdb PRxdc PRxdd PRxde PRxdf
                               PRxe0 PRxe1 PRxe2 PRxe3 PRxe4 PRxe5 PRxe6 PRxe7
                               PRxe8 PRxe9 PRxea PRxeb PRxec PRxed PRxee PRxef
                               PRxf0 PRxf1 PRxf2 PRxf3 PRxf4 PRxf5 PRxf6 PRxf7
                               PRxf8 PRxf9 PRxfa PRxfb PRxfc PRxfd PRxfe PRxff
                               ];


#--------------------------------------------------------------------------
# Tables

reladdr8: loc is simm8  [ loc = inst_start + operand_offset + 1 + simm8; ] { export *[ram]:4 loc; }
reladdr16: loc is simm16  [ loc = inst_start + operand_offset + 2 + simm16; ] { export *[ram]:4 loc; }
reladdr32: loc is simm32  [ loc = inst_start + operand_offset + 4 + simm32; ] { export *[ram]:4 loc; }

# condition codes (for branch)

cc: "NEQ"  is lownibble=2 { tmp:1 = !Z_F; export tmp; }
cc: "EQL"  is lownibble=3 { tmp:1 = Z_F; export tmp; }
cc: "GTR"  is lownibble=4 { tmp:1 = !(N_F || Z_F); export tmp; }
cc: "LEQ"  is lownibble=5 { tmp:1 = (N_F || Z_F); export tmp; }
cc: "GEQ"  is lownibble=8 { tmp:1 = !N_F; export tmp; }
cc: "LSS"  is lownibble=9 { tmp:1 = N_F; export tmp; }
cc: "GTRU" is lownibble=10 { tmp:1 = !(C_F || Z_F); export tmp; }
cc: "LEQU" is lownibble=11 { tmp:1 = (C_F || Z_F); export tmp; }
cc: "VC"  is lownibble=12 { tmp:1 = !V_F; export tmp; }
cc: "VS"  is lownibble=13 { tmp:1 = V_F; export tmp; }
cc: "CC"  is lownibble=14 { tmp:1 = !C_F; export tmp; }
cc: "CS"  is lownibble=15 { tmp:1 = C_F; export tmp; }

# effective addresses

#  byte
#   0-3: literal
# eab_a - not defined
eab: "S^#"^litval is mode67=0 & litval { export *[const]:1 litval; }
#   4: indexed - see below
#   5: register
eab_a: reg is mode=5 & reg { export reg; }
eab: reg is mode=5 & reg { tmp:1 = reg:1; export tmp; }
#   6: register deferred
eab_a: (reg) is mode=6 & reg { export reg; }
eab: (reg) is mode=6 & reg { export *:1 reg; }
#   7: auto decrement
eab_a: -(reg) is mode=7 & reg { reg = reg - 1; export reg; }
eab: -(reg) is mode=7 & reg { reg = reg - 1; export *:1 reg; }
#   8: auto increment
eab_a: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 1; export ptr; }
eab: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 1; export *:1 ptr; }
#   8: immediate mode
# eab_a doesn't make sense
eab: "I^#"^simm8 is mode=8 & reg=15; simm8 { export simm8; } 
#   9: auto increment deferred
eab_a: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export tmp; }
eab: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:1 tmp; }
#   9: absolute
eab_a: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export tmp; }
eab: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:1 tmp; }
#   10: byte displacement
eab_a: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export ptr; }
eab: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:1 ptr; }
#   10: byte relative
eab_a: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { tmp:4 = reladdr8; export tmp; }
eab: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:1 reladdr8; }
#   11: byte displacement deferred
eab_a: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export ptr; }
eab: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:1 ptr; }
#   11: byte relative deferred
eab_a: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export ptr; }
eab: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:1 ptr; }
#   12: word displacement
eab_a: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export ptr; }
eab: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:1 ptr; }
#   12: word relative
eab_a: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { tmp = reladdr16; export tmp; }
eab: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:1 reladdr16; }
#   13: word displacement deferred
eab_a: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export ptr; }
eab: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:1 ptr; }
#   13: word relative deferred
eab_a: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export ptr; }
eab: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:1 ptr; }
#   14: long displacement
eab_a: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export ptr; }
eab: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:1 ptr; }
#   14: long relative
eab_a: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { tmp = reladdr32; export tmp; }
eab: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:1 reladdr32; }
#   15: long displacement deferred
eab_a: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export ptr; }
eab: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:1 ptr; }
#   15: long relative deferred
eab_a: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export ptr; }
eab: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:1 ptr; }

#  word
eaw: "S^#"^litval is mode67=0 & litval { export *[const]:2 litval; }
eaw: reg is mode=5 & reg { tmp:2 = reg:2; export tmp; }
eaw: (reg) is mode=6 & reg { export *:2 reg; }
eaw: -(reg) is mode=7 & reg { reg = reg - 2; export *:2 reg; }
eaw: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 2; export *:2 ptr; }
eaw: "I^#"^simm16 is mode=8 & reg=15; simm16 { export simm16; } 
eaw: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:2 tmp; }
eaw: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:2 tmp; }
eaw: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:2 ptr; }
eaw: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:2 reladdr8; }
eaw: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:2 ptr; }
eaw: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:2 ptr; }
eaw: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:2 ptr; }
eaw: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:2 reladdr16; }
eaw: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:2 ptr; }
eaw: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:2 ptr; }
eaw: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:2 ptr; }
eaw: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:2 reladdr32; }
eaw: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:2 ptr; }
eaw: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:2 ptr; }

# eaw_a: "S^#"^litval is mode67=0 & litval { ptr:4 = inst_next - 1; export [ram]ptr; }
eaw_a: reg is mode=5 & reg { export reg; }
eaw_a: (reg) is mode=6 & reg { export reg; }
eaw_a: -(reg) is mode=7 & reg { reg = reg - 2; export reg; }
eaw_a: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 2; export ptr; }
# eaw_a: "I^#"^simm16 is mode=8 & reg=15; simm16 { ptr:4 = inst_next - 2; export [ram]ptr; } 
eaw_a: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export tmp; }
eaw_a: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export tmp; }
eaw_a: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export ptr; }
eaw_a: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export reladdr8; }
eaw_a: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export ptr; }
eaw_a: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export ptr; }
eaw_a: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export ptr; }
eaw_a: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export reladdr16; }
eaw_a: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export ptr; }
eaw_a: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export ptr; }
eaw_a: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export ptr; }
eaw_a: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export reladdr32; }
eaw_a: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export ptr; }
eaw_a: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export ptr; }

#  long
eal: "S^#"^litval is mode67=0 & litval { export *[const]:4 litval; }
eal: reg is mode=5 & reg { export reg; }
eal: (reg) is mode=6 & reg { export *reg; }
eal: -(reg) is mode=7 & reg { reg = reg - 4; export *reg; }
eal: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 4; export *ptr; }
eal: "I^#"^simm32 is mode=8 & reg=15; simm32 { export simm32; } 
eal: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export *:4 tmp; }
eal: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:4 tmp; }
eal: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:4 ptr; }
eal: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:4 reladdr8; }
eal: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:4 ptr; }
eal: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:4 ptr; }
eal: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:4 ptr; }
eal: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:4 reladdr16; }
eal: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:4 ptr; }
eal: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:4 ptr; }
eal: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:4 ptr; }
eal: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:4 reladdr32; }
eal: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:4 ptr; }
eal: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:4 ptr; }

# eal_a: "S^#"^litval is mode67=0 & litval { ptr:4 = inst_next - 1; export [ram]ptr; }
eal_a: reg is mode=5 & reg { export reg; }
eal_a: (reg) is mode=6 & reg { export reg; }
eal_a: -(reg) is mode=7 & reg { reg = reg - 4; export reg; }
eal_a: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 4; export ptr; }
# eal_a: "I^#"^simm32 is mode=8 & reg=15; simm32 { ptr:4 = inst_next - 4; export [ram]ptr; } 
eal_a: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 4; export tmp; }
eal_a: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export tmp; }
eal_a: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export ptr; }
eal_a: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export reladdr8; }
eal_a: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export ptr; }
eal_a: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export ptr; }
eal_a: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export ptr; }
eal_a: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export reladdr16; }
eal_a: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export ptr; }
eal_a: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export ptr; }
eal_a: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export ptr; }
eal_a: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export reladdr32; }
eal_a: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export ptr; }
eal_a: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export ptr; }

#  quad
eaq: "S^#"^litval is mode67=0 & litval { export *[const]:8 litval; }
eaq: reg is mode=5 & reg {
  rptr:4 = &reg + 4;
  reg1 = *[register]rptr;
  tmp:8 = reg1;
  tmp = tmp << 32;
  tmp = tmp + zext(reg);
  export tmp;
}
eaq: (reg) is mode=6 & reg { export *:8 reg; }
eaq: -(reg) is mode=7 & reg { reg = reg - 8; export *:8 reg; }
eaq: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 8; export *:8 ptr; }
eaq: "I^#"^simm64 is mode=8 & reg=15; simm64 { export simm64; } 
eaq: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 8; export *:8 tmp; }
eaq: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export *:8 tmp; }
eaq: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export *:8 ptr; }
eaq: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export *:8 reladdr8; }
eaq: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export *:8 ptr; }
eaq: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export *:8 ptr; }
eaq: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export *:8 ptr; }
eaq: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export *:8 reladdr16; }
eaq: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export *:8 ptr; }
eaq: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export *:8 ptr; }
eaq: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export *:8 ptr; }
eaq: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export *:8 reladdr32; }
eaq: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export *:8 ptr; }
eaq: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export *:8 ptr; }

# eaq_a: "S^#"^litval is mode67=0 & litval { ptr:4 = inst_next - 1; export [ram]ptr; }
eaq_a: (reg) is mode=6 & reg { export reg; }
eaq_a: -(reg) is mode=7 & reg { reg = reg - 8; export reg; }
eaq_a: (reg)+ is mode=8 & reg { ptr = reg; reg = reg + 8; export ptr; }
# eaq_a: "I^#"^simm64 is mode=8 & reg=15; simm64 { export simm64; } 
eaq_a: @(reg)+ is mode=9 & reg { tmp:4 = *:4 reg; reg = reg + 8; export tmp; }
eaq_a: "@#"^simm32 is mode=9 & reg=15; simm32 { ptr:4 = simm32; tmp = *:4 ptr; export tmp; }
eaq_a: "B^"^simm8(reg) is mode=10 & reg; simm8 { ptr = reg + simm8; export ptr; }
eaq_a: "B^"^reladdr8 is mode=10 & reg=15; reladdr8 { export reladdr8; }
eaq_a: "@B^"^simm8(reg) is mode=11 & reg; simm8 { oa = reg + simm8; ptr = *:4 oa; export ptr; }
eaq_a: "@B^"^reladdr8 is mode=11 & reg=15; reladdr8 { ptr = *:4 reladdr8; export ptr; }
eaq_a: "W^"^simm16(reg) is mode=12 & reg; simm16 { ptr = reg + simm16; export ptr; }
eaq_a: "W^"^reladdr16 is mode=12 & reg=15; reladdr16 { export reladdr16; }
eaq_a: "@W^"^simm16(reg) is mode=13 & reg; simm16 { oa = reg + simm16; ptr = *:4 oa; export ptr; }
eaq_a: "@W^"^reladdr16 is mode=13 & reg=15; reladdr16 { ptr = *:4 reladdr16; export ptr; }
eaq_a: "L^"^simm32(reg) is mode=14 & reg; simm32 { ptr = reg + simm32; export ptr; }
eaq_a: "L^"^reladdr32 is mode=14 & reg=15; reladdr32 { export reladdr32; }
eaq_a: "@L^"^simm32(reg) is mode=15 & reg; simm32 { oa = reg + simm32; ptr = *:4 oa; export ptr; }
eaq_a: "@L^"^reladdr32 is mode=15 & reg=15; reladdr32 { ptr = *:4 reladdr32; export ptr; }

# indexed
eab: eab_a[reg] is mode=4 & reg; eab_a { ptr:4 = eab_a + reg; export *:1 ptr; }
eaw: eaw_a[reg] is mode=4 & reg; eaw_a { ptr:4 = eaw_a + (2 * reg); export *:2 ptr; }
eal: eal_a[reg] is mode=4 & reg; eal_a { ptr:4 = eal_a + (4 * reg); export *:4 ptr; }
eaq: eaq_a[reg] is mode=4 & reg; eaq_a { ptr:4 = eaq_a + (8 * reg); export *:8 ptr; }


# readable <size> <anything>
rbx: eab is eab { tmp = eab; export tmp; }
rbx2: eab is eab { tmp = eab; export tmp; }
rwx: eaw is eaw { tmp = eaw; export tmp; }
rwx2: eaw is eaw { tmp = eaw; export tmp; }
rlx: eal is eal { tmp = eal; export tmp; }
rlx2: eal is eal { tmp = eal; export tmp; }
rlx3: eal is eal { tmp = eal; export tmp; }
rlx4: eal is eal { tmp = eal; export tmp; }

# readable float F
rfx: eal is eal { tmp = eal; export tmp; }
rfx2: eal is eal { tmp = eal; export tmp; }

# readable float D
rdx: eaq is eaq { tmp = eaq; export tmp; }
rdx2: eaq is eaq { tmp = eaq; export tmp; }

# fixme: ensure writable effective address
# modifiable <size> <anything>
mbx: eab is eab { tmp = eab; export tmp; }
mwx: eaw is eaw { tmp = eaw; export tmp; }
mlx: eal is eal { tmp = eal; export tmp; }
mlx2: eal is eal { tmp = eal; export tmp; }
mqx: eaq is eaq { tmp = eaq; export tmp; }

# modifiable float F
mfx: mlx is mlx { tmp = mlx; export tmp; }

# modifiable float D
mdx: mqx is mqx { tmp = mqx; export tmp; }

eab_a2: eab_a is eab_a { tmp = eab_a; export tmp; }
eab_a3: eab_a is eab_a { tmp = eab_a; export tmp; }


#--------------------------------------------------------------------------
# Mnemonics


#=========================================================================
# Integer-Arithmetic and Logical Instructions
#=========================================================================

:ADAWI eaw, mwx is opcode=0x58; eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }

:ADDB2 eab, mbx is opcode=0x80; eab; mbx { addflags(eab, mbx); tmp = eab + mbx; mbx = tmp; resflags(tmp); }
:ADDB3 eab, rbx, mbx is opcode=0x81; eab; rbx; mbx { addflags(eab, rbx); tmp = eab + rbx; mbx = tmp; resflags(tmp); }
:ADDW2 eaw, mwx is opcode=0xa0; eaw; mwx { addflags(eaw, mwx); tmp = eaw + mwx; mwx = tmp; resflags(tmp); }
:ADDW3 eaw, rwx, mwx is opcode=0xa1; eaw; rwx; mwx { addflags(eaw, rwx); tmp = eaw + rwx; mwx = tmp; resflags(tmp); }
:ADDL2 eal, mlx is opcode=0xc0; eal; mlx { addflags(eal, mlx); tmp = eal + mlx; mlx = tmp; resflags(tmp); }
:ADDL3 eal, rlx, mlx is opcode=0xc1; eal; rlx; mlx { addflags(eal, rlx); tmp = eal + rlx; mlx = tmp; resflags(tmp); }

:ADWC eal, mlx is opcode=0xD8; eal; mlx { cf:4 = zext(C_F); addcflags(eal, mlx, cf); tmp = eal + mlx + cf; mlx = tmp; resflags(tmp); }

:ASHL eab, eal, mlx is opcode=0x78; eab; eal; mlx {
  if (eab s> 31) goto <result_zero>;
  if (eab s< 30) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mlx = 0;
  goto <end>;
<shift_left>
  mlx = eal << (eab & 0x1F);
  goto <end>;
<shift_right>
  mlx = eal >> (eab & 0x1F);
  goto <end>;
<result_sign>
  if (eal s> 0) goto <result_zero>;
  mlx = -1;
  goto <end>;
<end>
  resflags(mlx);
  C_F = 0;
}
:ASHQ eab, eaq, mqx is opcode=0x79; eab; eaq; mqx {
  if (eab s> 63) goto <result_zero>;
  if (eab s< 62) goto <result_sign>;
  if (eab s> 0) goto <shift_left>;
  if (eab s< 0) goto <shift_right>;
  # eab == 0: fallthrough to <result_zero>
<result_zero>
  mqx = 0;
  goto <end>;
<shift_left>
  mqx = eaq << (eab & 0x3F);
  goto <end>;
<shift_right>
  mqx = eaq >> (eab & 0x3F);
  goto <end>;
<result_sign>
  if (eaq s> 0) goto <result_zero>;
  mqx = -1;
  goto <end>;
<end>
  resflags(mqx);
  C_F = 0;
}

:BICB2 eab, mbx is opcode=0x8a; eab; mbx { tmp:1 = mbx & ~(eab); mbx = tmp; resflags(tmp); V_F = 0; }
:BICB3 eab, rbx, mbx is opcode=0x8b; eab; rbx; mbx { tmp:1 = rbx & ~(eab); mbx = tmp; resflags(tmp); V_F = 0; }
:BICW2 eaw, mwx is opcode=0xaa; eaw; mwx { tmp:2 = mwx & ~(eaw); mwx = tmp; resflags(tmp); V_F = 0; }
:BICW3 eaw, rwx, mwx is opcode=0xab; eaw; rwx; mwx { tmp:2 = rwx & ~(eaw); mwx = tmp; resflags(tmp); V_F = 0; }
:BICL2 eal, mlx is opcode=0xca; eal; mlx { tmp:4 = mlx & ~(eal); mlx = tmp; resflags(tmp); V_F = 0; }
:BICL3 eal, rlx, mlx is opcode=0xcb; eal; rlx; mlx { tmp:4 = rlx & ~(eal); mlx = tmp; resflags(tmp); V_F = 0; }

:BISB2 eab, mbx is opcode=0x88; eab; mbx { tmp:1 = mbx | eab; mbx = tmp; resflags(tmp); V_F = 0; }
:BISB3 eab, rbx, mbx is opcode=0x89; eab; rbx; mbx { tmp:1 = rbx | eab; mbx = tmp; resflags(tmp); V_F = 0; }
:BISW2 eaw, mwx is opcode=0xa8; eaw; mwx { tmp:2 = mwx | eaw; mwx = tmp; resflags(tmp); V_F = 0; }
:BISW3 eaw, rwx, mwx is opcode=0xa9; eaw; rwx; mwx { tmp:2 = rwx | eaw; mwx = tmp; resflags(tmp); V_F = 0; }
:BISL2 eal, mlx is opcode=0xc8; eal; mlx { tmp:4 = mlx | eal; mlx = tmp; resflags(tmp); V_F = 0; }
:BISL3 eal, rlx, mlx is opcode=0xc9; eal; rlx; mlx { tmp:4 = rlx | eal; mlx = tmp; resflags(tmp); V_F = 0; }

:BIZB2 eab, rbx is opcode=0x93; eab; rbx { tmp:1 = rbx & eab; resflags(tmp); V_F = 0; }
:BITW2 eaw, rwx is opcode=0xb3; eaw; rwx { tmp:2 = rwx & eaw; resflags(tmp); V_F = 0; }
:BITL2 eal, rlx is opcode=0xd3; eal; rlx { tmp:4 = rlx & eal; resflags(tmp); V_F = 0; }

:CLRB eab is opcode=0x94; eab { eab = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRW eaw is opcode=0xb4; eaw { eaw = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRL eal is opcode=0xd4; eal { eal = 0; N_F = 0; Z_F = 1; V_F = 1; }
:CLRQ eaq is opcode=0x7c; eaq { eaq = 0; N_F = 0; Z_F = 1; V_F = 1; }
#:CLRO eao is opcodew=0x7CFD

:CMPB eab, rbx is opcode=0x91; eab; rbx { cmpflags(eab, rbx); }
:CMPW eaw, rwx is opcode=0xb1; eaw; rwx { cmpflags(eaw, rwx); }
:CMPL eal, rlx is opcode=0xD1; eal; rlx { cmpflags(eal, rlx); }

:CVTBW eab, mwx is opcode=0x99; eab; mwx { tmp:2 = sext(eab); mwx = tmp; resflags(tmp); C_F = 0; }
:CVTBL eab, mlx is opcode=0x98; eab; mlx { tmp:4 = sext(eab); mlx = tmp; resflags(tmp); C_F = 0; }
:CVTWL eaw, mlx is opcode=0x32; eaw; mlx { tmp:4 = sext(eaw); mlx = tmp; resflags(tmp); C_F = 0; }
:CVTWB eaw, mbx is opcode=0x33; eaw; mbx {
  tmp = eaw:1;
  remaining:2 = (eaw & 0xff00);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xff00);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mbx = tmp;
  resflags(tmp);
  C_F = 0;
}
:CVTLB eal, mbx is opcode=0xf6; eal; mbx {
  tmp = eal:1;
  remaining:4 = (eal & 0xffffff00);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xffffff00);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mbx = tmp;
  resflags(tmp);
  C_F = 0;
}
:CVTLW eal, mwx is opcode=0xf7; eal; mwx {
  tmp = eal:2;
  remaining:4 = (eal & 0xffff0000);
  tmpsign = (tmp & 0x80);
  if (tmpsign == 0) goto <must_be_positive>;
  V_F = !(remaining == 0xffff0000);
  goto <end>;
<must_be_positive>
  V_F = !(remaining == 0);
<end>
  mwx = tmp;
  resflags(tmp);
  C_F = 0;
}

:DECB mbx is opcode=0x97; mbx {
  if (mbx == 0x80) goto <underflow>;
  if (mbx == 0) goto <negative>;
  mbx = mbx - 1;
  goto <end>;
<underflow>
  mbx = 0x7f;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mbx = 0xff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mbx);
}
:DECW mwx is opcode=0xb7; mwx {
  if (mwx == 0x8000) goto <underflow>;
  if (mwx == 0) goto <negative>;
  mwx = mwx - 1;
  goto <end>;
<underflow>
  mwx = 0x7fff;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mwx = 0xffff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mwx);
}
:DECL mlx is opcode=0xd7; mlx {
  if (mlx == 0x80000000) goto <underflow>;
  if (mlx == 0) goto <negative>;
  mlx = mlx - 1;
  goto <end>;
<underflow>
  mlx = 0x7fffffff;
  V_F = 1;
  C_F = 0;
  goto <end>;
<negative>
  mlx = 0xffffffff;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mlx);
}

:DIVB2 eab, mbx is opcode=0x86; eab; mbx { mbx = mbx / eab; C_F = 0; resflags(mbx); } # FIXME V_F
:DIVB3 eab, rbx, mbx is opcode=0x87; eab; rbx; mbx { mbx = rbx / eab; C_F = 0; resflags(mbx); } # FIXME V_F
:DIVW2 eaw, mwx is opcode=0xa6; eaw; mwx { mwx = mwx / eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:DIVW3 eaw, rwx, mwx is opcode=0xa7; eaw; rwx; mwx { mwx = rwx / eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:DIVL2 eal, mlx is opcode=0xc6; eal; mlx { mlx = mlx / eal; C_F = 0; resflags(mlx); } # FIXME V_F
:DIVL3 eal, rlx, mlx is opcode=0xc7; eal; rlx; mlx { mlx = rlx / eal; C_F = 0; resflags(mlx); } # FIXME V_F

:EDIV eal, eaq, mlx, mlx2 is opcode=0x7b; eal; eaq; mlx; mlx2 { divr:8 = sext(eal); quo = eaq / divr; mlx = quo:4; rem = eaq % divr; mlx2 = rem:4; C_F = 0; resflags(mlx); } # FIXME V_F
:EMUL eal, rlx, rlx2, mqx is opcode=0x7a; eal; rlx; rlx2; mqx { mqx = sext(rlx * eal) + sext(rlx2); V_F = 0; C_F = 0; resflags(mqx); }

:INCB mbx is opcode=0x96; mbx {
  if (mbx == 0x7f) goto <overflow>;
  if (mbx == 0xff) goto <positive>;
  mbx = mbx + 1;
  goto <end>;
<overflow>
  mbx = 0x80;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mbx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mbx);
}
:INCW mwx is opcode=0xb6; mwx {
  if (mwx == 0x7fff) goto <overflow>;
  if (mwx == 0xffff) goto <positive>;
  mwx = mwx + 1;
  goto <end>;
<overflow>
  mwx = 0x8000;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mwx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mwx);
}
:INCL mlx is opcode=0xd6; mlx {
  if (mlx == 0x7fffffff) goto <overflow>;
  if (mlx == 0xffffffff) goto <positive>;
  mlx = mlx + 1;
  goto <end>;
<overflow>
  mlx = 0x80000000;
  V_F = 1;
  C_F = 0;
  goto <end>;
<positive>
  mlx = 0;
  C_F = 1;
  V_F = 0;
<end>
  resflags(mlx);
}

:MCOMB eab, mbx is opcode=0x92; eab; mbx { mbx = ~eab; V_F = 0; resflags(mbx); }
:MCOMW eaw, mwx is opcode=0xb2; eaw; mwx { mwx = ~eaw; V_F = 0; resflags(mwx); }
:MCOML eal, mlx is opcode=0xd2; eal; mlx { mlx = ~eal; V_F = 0; resflags(mlx); }

:MNEGB eab, mbx is opcode=0x8e; eab; mbx {
  if (eab == 0x80) goto <overflow>;
  mbx = -eab;
  goto <end>;
<overflow>
  mbx = eab;
<end>
  V_F = 0; resflags(mbx);
}
:MNEGW eaw, mwx is opcode=0xae; eaw; mwx {
  if (eaw == 0x8000) goto <overflow>;
  mwx = -eaw;
  goto <end>;
<overflow>
  mwx = eaw;
<end>
  V_F = 0; resflags(mwx);
}
:MNEGL eal, mlx is opcode=0xce; eal; mlx {
  if (eal == 0x80000000) goto <overflow>;
  mlx = -eal;
  goto <end>;
<overflow>
  mlx = eal;
<end>
  V_F = 0; resflags(mlx);
}

:MOVB eab, mbx is opcode=0x90; eab; mbx { mbx = eab; V_F = 0; resflags(mbx); }
:MOVW eaw, mwx is opcode=0xb0; eaw; mwx { mwx = eaw; V_F = 0; resflags(mwx); }
:MOVL eal, mlx is opcode=0xd0; eal; mlx { mlx = eal; V_F = 0; resflags(mlx); }
:MOVQ eaq, mqx is opcode=0x7d; eaq; mqx { mqx = eaq; V_F = 0; resflags(mqx); }
#:MOVO FIXME

:MOVZBW eab, mwx is opcode=0x9b; eab; mwx { mwx = zext(eab); resflags(mwx); N_F = 0; V_F = 0; }
:MOVZBL eab, mlx is opcode=0x9a; eab; mlx { mlx = zext(eab); resflags(mlx); N_F = 0; V_F = 0; }
:MOVZWL eaw, mlx is opcode=0x3c; eaw; mlx { mlx = zext(eaw); resflags(mlx); N_F = 0; V_F = 0; }

:MULB2 eab, mbx is opcode=0x84; eab; mbx { mbx = mbx * eab; C_F = 0; resflags(mbx); } # FIXME V_F
:MULB3 eab, rbx, mbx is opcode=0x85; eab; rbx; mbx { mbx = rbx * eab; C_F = 0; resflags(mbx); } # FIXME V_F
:MULW2 eaw, mwx is opcode=0xa4; eaw; mwx { mwx = mwx * eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:MULW3 eaw, rwx, mwx is opcode=0xa5; eaw; rwx; mwx { mwx = rwx * eaw; C_F = 0; resflags(mwx); } # FIXME V_F
:MULL2 eal, mlx is opcode=0xc4; eal; mlx { mlx = mlx * eal; C_F = 0; resflags(mlx); } # FIXME V_F
:MULL3 eal, rlx, mlx is opcode=0xc5; eal; rlx; mlx { mlx = rlx * eal; C_F = 0; resflags(mlx); } # FIXME V_F

:PUSHL eal is opcode=0xdd; eal { push(eal); V_F = 0; resflags(eal); }

:ROTL eab, eal, mlx is opcode=0x9c; eab; eal; mlx {
  if (eab s> 0) goto <rotate_left>;
  if (eab s< 0) goto <rotate_right>;
  mlx = eal;
  goto <end>;
<rotate_left>
  shifted = eal << eab;
  rot_bits = eal >> (32-eab);
  mlx = shifted | rot_bits;
  goto <end>;
<rotate_right>
  shifted = eal >> eab;
  rot_bits = eal << (32+eab); # eab is negative
  mlx = shifted | rot_bits;
<end>
  V_F = 0;
  resflags(mlx);
}

:SBWC eal, mlx is opcode=0xD9; eal; mlx { cf:4 = zext(C_F); subcflags(eal, mlx, cf); tmp = eal - mlx - cf; mlx = tmp; resflags(tmp); }

:SUBB2 eab, mbx is opcode=0x82; eab; mbx { subflags(eab, mbx); tmp = eab - mbx; mbx = tmp; resflags(tmp); }
:SUBB3 eab, rbx, mbx is opcode=0x83; eab; rbx; mbx { subflags(eab, rbx); tmp = eab - rbx; mbx = tmp; resflags(tmp); }
:SUBW2 eaw, mwx is opcode=0xa2; eaw; mwx { subflags(eaw, mwx); tmp = eaw - mwx; mwx = tmp; resflags(tmp); }
:SUBW3 eaw, rwx, mwx is opcode=0xa3; eaw; rwx; mwx { subflags(eaw, rwx); tmp = eaw - rwx; mwx = tmp; resflags(tmp); }
:SUBL2 eal, mlx is opcode=0xc2; eal; mlx { subflags(eal, mlx); tmp = eal - mlx; mlx = tmp; resflags(tmp); }
:SUBL3 eal, rlx, mlx is opcode=0xc3; eal; rlx; mlx { subflags(eal, rlx); tmp = eal - rlx; mlx = tmp; resflags(tmp); }

:TSTB eab is opcode=0x95; eab { V_F = 0; C_F = 0; resflags(eab); }
:TSTW eaw is opcode=0xb5; eaw { V_F = 0; C_F = 0; resflags(eaw); }
:TSTL eal is opcode=0xd5; eal { V_F = 0; C_F = 0; resflags(eal); }

:XORB2 eab, mbx is opcode=0x8c; eab; mbx { tmp = eab ^ mbx; mbx = tmp; V_F = 0; resflags(tmp); }
:XORB3 eab, rbx, mbx is opcode=0x8d; eab; rbx; mbx { tmp = eab ^ rbx; mbx = tmp; V_F = 0; resflags(tmp); }
:XORW2 eaw, mwx is opcode=0xac; eaw; mwx { tmp = eaw ^ mwx; mwx = tmp; V_F = 0; resflags(tmp); }
:XORW3 eaw, rwx, mwx is opcode=0xad; eaw; rwx; mwx { tmp = eaw ^ rwx; mwx = tmp; V_F = 0; resflags(tmp); }
:XORL2 eal, mlx is opcode=0xcc; eal; mlx { tmp = eal ^ mlx; mlx = tmp; V_F = 0; resflags(tmp); }
:XORL3 eal, rlx, mlx is opcode=0xcd; eal; rlx; mlx { tmp = eal ^ rlx; mlx = tmp; V_F = 0; resflags(tmp); }

#=========================================================================
# Address Instructions
#=========================================================================

:MOVAB eab_a, mlx is opcode=0x9e; eab_a; mlx { mlx = eab_a; V_F = 0; resflags(mlx); }
:MOVAW eaw_a, mlx is opcode=0x3e; eaw_a; mlx { mlx = eaw_a; V_F = 0; resflags(mlx); }
:MOVAL eal_a, mlx is opcode=0xde; eal_a; mlx { mlx = eal_a; V_F = 0; resflags(mlx); }
:MOVAQ eaq_a, mlx is opcode=0x7e; eaq_a; mlx { mlx = eaq_a; V_F = 0; resflags(mlx); }

:PUSHAB eab_a is opcode=0x9f; eab_a { push(eab_a); V_F = 0; resflags(eab_a); }
:PUSHAW eaw_a is opcode=0x3f; eaw_a { push(eaw_a); V_F = 0; resflags(eaw_a); }
:PUSHAL eal_a is opcode=0xdf; eal_a { push(eal_a); V_F = 0; resflags(eal_a); }
:PUSHAQ eaq_a is opcode=0x7f; eaq_a { push(eaq_a); V_F = 0; resflags(eaq_a); }

#=========================================================================
# Variable-Length Bit-Field Instructions
#=========================================================================

:CMPV eal, eab, eab_a, rlx is opcode=0xec; eal; eab; eab_a; rlx {
  if (eab == 0) goto <size_zero>;
  local f:4;
  set_field(f, eal, eab, eab_a);
  goto <end>;
<size_zero>
  f = 0;
<end>
  cmpflags(f, rlx);
}
:CMPZV eal, eab, eab_a, rlx is opcode=0xed; eal; eab; eab_a; rlx {
  if (eab == 0) goto <size_zero>;
  local f:4;
  set_field(f, eal, eab, eab_a);
  goto <end>;
<size_zero>
  f = 0;
<end>
  cmpflags(f, rlx);
}

:EXTV eal, eab, eab_a, mlx is opcode=0xee; eal; eab; eab_a; mlx {
  if (eab == 0) goto <size_zero>;
  local f:4;
  set_field(f, eal, eab, eab_a);
  goto <end>;
<size_zero>
  f = 0;
<end>
  mlx = f;
  resflags(f);
}
:EXTZV eal, eab, eab_a, mlx is opcode=0xef; eal; eab; eab_a; mlx {
  if (eab == 0) goto <size_zero>;
  local f:4;
  set_field(f, eal, eab, eab_a);
  goto <end>;
<size_zero>
  f = 0;
<end>
  mlx = f;
  resflags(f);
}

:FFC eal, eab, eab_a, mlx is opcode=0xeb; eal; eab; eab_a; mlx {
  N_F = 0; V_F = 0; C_F = 0;
  # FIXME
}
:FFS eal, eab, eab_a, mlx is opcode=0xea; eal; eab; eab_a; mlx {
  N_F = 0; V_F = 0; C_F = 0;
  # FIXME
}

:INSV eal, rlx, eab, eab_a is opcode=0xf0; eal; rlx; eab; eab_a {
  if (eab == 0) goto <end>;
  # FIXME
<end>
}

#=========================================================================
# Control Instructions
#=========================================================================

:ACBB eab, rbx, mbx, reladdr16 is opcode=0x9d; eab; rbx; mbx; reladdr16 {
  mbx = mbx + rbx;
  if (((rbx s>= 0) && (mbx <= eab)) || ((rbx s< 0) && (mbx >= eab))) goto reladdr16;
}
:ACBW eaw, rwx, mwx, reladdr16 is opcode=0x3d; eaw; rwx; mwx; reladdr16 {
  mwx = mwx + rwx;
  if (((rwx s>= 0) && (mwx <= eaw)) || ((rwx s< 0) && (mwx >= eaw))) goto reladdr16;
}
:ACBL eal, rlx, mlx, reladdr16 is opcode=0xf1; eal; rlx; mlx; reladdr16 {
  mlx = mlx + rlx;
  if (((rlx s>= 0) && (mlx <= eal)) || ((rlx s< 0) && (mlx >= eal))) goto reladdr16;
}
# FIXME :ACBF is opcode=0x4f
# FIXME :ACBD is opcode=0x6f

:AOBLEQ eal, mlx, reladdr8 is opcode=0xf3; eal; mlx; reladdr8 {
  mlx = mlx + 1;
  if (mlx <= eal) goto reladdr8;
}
:AOBLSS eal, mlx, reladdr8 is opcode=0xf2; eal; mlx; reladdr8 {
  mlx = mlx + 1;
  if (mlx s< eal) goto reladdr8;
}

:B^cc reladdr8 is highnibble=1 & cc; reladdr8 {
  if (cc) goto reladdr8;
}

:BBS eal, eab_a, reladdr8 is opcode=0xe0; eal; eab_a; reladdr8 {
  local f:4;
  set_field(f, eal, 1, eab_a);
  if (f == 1) goto reladdr8;
}
:BBC eal, eab_a, reladdr8 is opcode=0xe1; eal; eab_a; reladdr8 {
  local f:4;
  set_field(f, eal, 1, eab_a);
  if (f == 0) goto reladdr8;
}
:BBSS eal, eab_a, reladdr8 is opcode=0xe2; eal; eab_a; reladdr8 {
  teststate:1 = 1;
#  newstate:1 = 1;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}
:BBCS eal, eab_a, reladdr8 is opcode=0xe3; eal; eab_a; reladdr8 {
  teststate:1 = 0;
#  newstate:1 = 1;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}
:BBSC eal, eab_a, reladdr8 is opcode=0xe4; eal; eab_a; reladdr8 {
  teststate:1 = 1;
#  newstate:1 = 0;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}
:BBCC eal, eab_a, reladdr8 is opcode=0xe5; eal; eab_a; reladdr8 {
  teststate:1 = 0;
#  newstate:1 = 0;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}
:BBSSI eal, eab_a, reladdr8 is opcode=0xe6; eal; eab_a; reladdr8 {
  teststate:1 = 1;
#  newstate:1 = 1;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}
:BBCCI eal, eab_a, reladdr8 is opcode=0xe7; eal; eab_a; reladdr8 {
  teststate:1 = 0;
#  newstate:1 = 0;
  local tmp:4;
  set_field(tmp, eal, 1, eab_a);
  # FIXME write field
  if (tmp:1 == teststate) goto reladdr8;
}

:BLBS eal, reladdr8 is opcode=0xe8; eal; reladdr8 {
  local tmp:1 = eal:1 & 0x01;
  if (tmp == 1) goto reladdr8;
}
:BLBC eal, reladdr8 is opcode=0xe9; eal; reladdr8 {
  local tmp:1 = eal:1 & 0x01;
  if (tmp == 0) goto reladdr8;
}

:BRB reladdr8 is opcode=0x11; reladdr8 {
  goto reladdr8;
}
:BRW reladdr16 is opcode=0x31; reladdr16 {
  goto reladdr16;
}

:BSBB reladdr8 is opcode=0x10; reladdr8 {
  ptr:4 = inst_next;
  push(ptr);
  call reladdr8;
}
:BSBW reladdr16 is opcode=0x30; reladdr16 {
  ptr:4 = inst_next;
  push(ptr);
  call reladdr16;
}

:CASEB eab, rbx, rbx2 is opcode=0x8f; eab; rbx; rbx2 {
  local tmp = eab - rbx; # offset into jump table (of words)
  if (tmp > rbx2) goto <not_lequ>; # unsigned compare !, also break out here if tmp is 'negative'
  local table = inst_next;
  local offset:4 = 0;
  idx:2 = zext(tmp) + zext(tmp); # offset table has words
  ptr:4 = table + sext(idx); # ptr into table
  offset = sext(*:2 ptr); # get table entry
  goto <end>;
<not_lequ>
  offset = 2*zext(rbx2) + 2; # skip to end of table
<end>
  ptr = inst_next;
  ptr = ptr + offset;
  goto [ptr];
}
:CASEW eaw, rwx, rwx2 is opcode=0xaf; eaw; rwx; rwx2 {
  local tmp = eaw - rwx; # offset into jump table (of words)
  if (tmp > rwx2) goto <not_lequ>; # unsigned compare !, also break out here if tmp is 'negative'
  local table = inst_next;
  local offset:4 = 0;
  idx:4 = zext(tmp) + zext(tmp); # offset table has words
  ptr:4 = table + idx; # ptr into table
  offset = sext(*:2 ptr); # get table entry
  goto <end>;
<not_lequ>
  offset = 2*zext(rwx2) + 2; # skip to end of table
<end>
  ptr = inst_next;
  ptr = ptr + offset;
  goto [ptr];
}
:CASEL eal, rlx, rlx2 is opcode=0xcf; eal; rlx; rlx2 {
  local tmp = eal - rlx; # offset into jump table (of words)
  if (tmp > rlx2) goto <not_lequ>; # unsigned compare !, also break out here if tmp is 'negative'
  local table = inst_next;
  local offset:4 = 0;
  idx:4 = tmp + tmp; # offset table has words
  ptr:4 = table + idx; # ptr into table
  offset = sext(*:2 ptr); # get table entry
  goto <end>;
<not_lequ>
  offset = 2*rlx2 + 2; # skip to end of table
<end>
  ptr = inst_next;
  ptr = ptr + offset;
  goto [ptr];
}

:JMP eab_a is opcode=0x17; eab_a {
  goto [eab_a];
}
:JSB eab_a is opcode=0x16; eab_a {
  ptr:4 = inst_next;
  push(ptr);
  goto [eab_a];
}

:RSB is opcode=0x05 { pop(PC); return [PC]; }

:SOBGEQ mlx, reladdr8 is opcode=0xf4; mlx; reladdr8 {
  mlx = mlx - 1;
  resflags(mlx);
  if (mlx != 0x7fffffff) goto <no_v>;
  V_F = 1;
<no_v>
  if (mlx s>= 0) goto reladdr8;
}
:SOBGTR mlx, reladdr8 is opcode=0xf5; mlx; reladdr8 {
  mlx = mlx - 1;
  resflags(mlx);
  if (mlx != 0x7fffffff) goto <no_v>;
  V_F = 1;
<no_v>
  if (mlx s> 0) goto reladdr8;
}

:CALLG eab_a, eab_a2 is opcode=0xfa; eab_a; eab_a2 {
  ptr:4 = eab_a2 + 2;
  # FIXME
  call [ptr];
}
:CALLS eal, eab_a is opcode=0xfb; eal; eab_a {
  ptr:4 = eab_a + 2;
  # FIXME
  call [ptr];
}
:RET is opcode=0x04 {
  pop(PC);
  return [PC];
}

#=========================================================================
# Miscellaneous Instructions
#=========================================================================

# FIXME unpack/pack from condition flags
:BICPSW eaw is opcode=0xb9; eaw { PSW = PSW & ~eaw; }
:BISPSW eaw is opcode=0xb8; eaw { PSW = PSW | eaw; }

:BPT is opcode=0x03 unimpl
:HALT is opcode=0x00 { goto inst_start; }

:INDEX eal, rlx, rlx2, rlx3, rlx4, mlx is opcode=0x0a; eal; rlx; rlx2; rlx3; rlx4; mlx {
  mlx = (rlx4 + eal) * rlx3;
  if ((eal s< rlx) || (eal > rlx2)) goto <end>;
  resflags(mlx);
<end>
}

:MOVPSL mlx is opcode=0xdc; mlx { mlx = PSL; }

:NOP is opcode=0x01 { goto inst_next; }

:POPR eaw is opcode=0xba; eaw {
  if ((eaw & 0x0001) == 0) goto<no_r0>;
  pop(R0);
<no_r0>
  if ((eaw & 0x0002) == 0) goto<no_r1>;
  pop(R1);
<no_r1>
  if ((eaw & 0x0004) == 0) goto<no_r2>;
  pop(R2);
<no_r2>
  if ((eaw & 0x0008) == 0) goto<no_r3>;
  pop(R3);
<no_r3>
  if ((eaw & 0x0010) == 0) goto<no_r4>;
  pop(R4);
<no_r4>
  if ((eaw & 0x0020) == 0) goto<no_r5>;
  pop(R5);
<no_r5>
  if ((eaw & 0x0040) == 0) goto<no_r6>;
  pop(R6);
<no_r6>
  if ((eaw & 0x0080) == 0) goto<no_r7>;
  pop(R7);
<no_r7>
  if ((eaw & 0x0100) == 0) goto<no_r8>;
  pop(R8);
<no_r8>
  if ((eaw & 0x0200) == 0) goto<no_r9>;
  pop(R9);
<no_r9>
  if ((eaw & 0x0400) == 0) goto<no_r10>;
  pop(R10);
<no_r10>
  if ((eaw & 0x0800) == 0) goto<no_r11>;
  pop(R11);
<no_r11>
  if ((eaw & 0x1000) == 0) goto<no_ap>;
  pop(AP);
<no_ap>
  if ((eaw & 0x2000) == 0) goto<no_fp>;
  pop(FP);
<no_fp>
  if ((eaw & 0x4000) == 0) goto<no_sp>;
  pop(SP);
<no_sp>
}

:PUSHR eaw is opcode=0xbb; eaw {
  if ((eaw & 0x4000) == 0) goto<no_sp>;
  push(SP);
<no_sp>
  if ((eaw & 0x2000) == 0) goto<no_fp>;
  push(FP);
<no_fp>
  if ((eaw & 0x1000) == 0) goto<no_ap>;
  push(AP);
<no_ap>
  if ((eaw & 0x0800) == 0) goto<no_r11>;
  push(R11);
<no_r11>
  if ((eaw & 0x0400) == 0) goto<no_r10>;
  push(R10);
<no_r10>
  if ((eaw & 0x0200) == 0) goto<no_r9>;
  push(R9);
<no_r9>
  if ((eaw & 0x0080) == 0) goto<no_r7>;
  push(R7);
<no_r8>
  if ((eaw & 0x0040) == 0) goto<no_r6>;
  push(R6);
<no_r7>
  if ((eaw & 0x0100) == 0) goto<no_r8>;
  push(R8);
<no_r6>
  if ((eaw & 0x0020) == 0) goto<no_r5>;
  push(R5);
<no_r5>
  if ((eaw & 0x0010) == 0) goto<no_r4>;
  push(R4);
<no_r4>
  if ((eaw & 0x0008) == 0) goto<no_r3>;
  push(R3);
<no_r3>
  if ((eaw & 0x0004) == 0) goto<no_r2>;
  push(R2);
<no_r2>
  if ((eaw & 0x0002) == 0) goto<no_r1>;
  push(R1);
<no_r1>
  if ((eaw & 0x0001) == 0) goto<no_r0>;
  push(R0);
<no_r0>
}

:XFC is opcode=0xfc unimpl

#=========================================================================
# Queue Instructions
#=========================================================================
# FIXME

:INSQHI eab, eaq is opcode=0x5c; eab; eaq unimpl
:INSQTI eab, eaq is opcode=0x5d; eab; eaq unimpl
:INSQUE eab, mbx is opcode=0x0e; eab; mbx unimpl
:REMQHI eaq, eal is opcode=0x5e; eaq; eal unimpl
:REMQTI eaq, eal is opcode=0x5f; eaq; eal unimpl
:REMQUE eab, eal is opcode=0x0f; eab; eal unimpl

#=========================================================================
# Floating-Point Instructions
#=========================================================================
# FIXME

:ADDF2 rfx, mfx is opcode=0x40; rfx; mfx {
  mfx = mfx f+ rfx;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:ADDF3 rfx, rfx2, mfx is opcode=0x41; rfx; rfx2; mfx {
  mfx = rfx f+ rfx2;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:ADDD2 rdx, mdx is opcode=0x60; rdx; mdx {
  mdx = mdx f+ rdx;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}
:ADDD3 rdx, rdx2, mdx is opcode=0x61; rdx; rdx2; mdx {
  mdx = rdx f+ rdx2;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}

:CMPF rfx, rfx2 is opcode=0x51; rfx; rfx2 {
  cmpfflags(rfx,rfx2);
}
:CMPD rdx, rdx2 is opcode=0x71; rdx; rdx2 {
  cmpfflags(rdx,rdx2);
}

:CVTBF rbx, mfx is opcode=0x4c; rbx; mfx {
  mfx = int2float(rbx);
}
:CVTWF rwx, mfx is opcode=0x4d; rwx; mfx {
  mfx = int2float(rwx);
}
:CVTLF rlx, mfx is opcode=0x4e; rlx; mfx {
  mfx = int2float(rlx);
}
:CVTBD rbx, mdx is opcode=0x6c; rbx; mdx {
  mdx = int2float(rbx);
}
:CVTWD rwx, mdx is opcode=0x6d; rwx; mdx {
  mdx = int2float(rwx);
}
:CVTLD rlx, mdx is opcode=0x6e; rlx; mdx {
  mdx = int2float(rlx);
}
:CVTFB rfx, mbx is opcode=0x48; rfx; mbx {
  mbx = trunc(rfx);
}
:CVTFW rfx, mwx is opcode=0x49; rfx; mwx {
  mwx = trunc(rfx);
}
:CVTFL rfx, mlx is opcode=0x4a; rfx; mlx {
  mlx = trunc(rfx);
}
:CVTDB rdx, mbx is opcode=0x68; rdx; mbx {
  mbx = trunc(rdx);
}
:CVTDW rdx, mwx is opcode=0x69; rdx; mwx {
  mwx = trunc(rdx);
  resflags(mwx);
  C_F = 0;
}
:CVTDL rdx, mlx is opcode=0x6a; rdx; mlx {
  mlx = trunc(rdx);
  resflags(mlx);
  C_F = 0;
}
:CVTFD rfx, mdx is opcode=0x56; rfx; mdx {
  mdx = float2float(rfx);
  resfflags(mdx);
  C_F = 0;
}
:CVTDF rdx, mfx is opcode=0x76; rdx; mfx {
  mfx = float2float(rdx);
  resfflags(mfx);
  C_F = 0;
}

:DIVF2 rfx, mfx is opcode=0x46; rfx; mfx {
  mfx = mfx f/ rfx;
  resfflags(mfx);
  C_F = 0;
}
:DIVF3 rfx, rfx2, mfx is opcode=0x47; rfx; rfx2; mfx {
  mfx = rfx f/ rfx2;
  resfflags(mfx);
  C_F = 0;
}

:DIVD2 rdx, mdx is opcode=0x66; rdx; mdx {
  mdx = mdx f/ rdx;
  resfflags(mdx);
  C_F = 0;
}
:DIVD3 rdx, rdx2, mdx is opcode=0x67; rdx; rdx2; mdx {
  mdx = rdx f/ rdx2;
  resfflags(mdx);
  C_F = 0;
}

:EMODF rfx, rbx, rfx2, mlx, mfx is opcode=0x54; rfx; rbx; rfx2; mlx; mfx {
  product = rfx f* rfx2;
  mlx = trunc(product);   # integer part
  mfx = product - int2float(mlx); # fractional part
  resfflags(mfx);
  C_F = 0;
}

:EMODD rdx, rbx, rdx2, mlx, mdx is opcode=0x74; rdx; rbx; rdx2; mlx; mdx {
  product = rdx f* rdx2;
  mlx = trunc(product);   # integer part
  mdx = product - int2float(mlx); # fractional part
  resfflags(mdx);
  C_F = 0;
}

:MNEGF rfx, mfx is opcode=0x52; rfx; mfx {
  mfx = -rfx;
  resfflags(mfx);
  C_F = 0;
  V_F = 0;
}
:MNEGD rdx, mdx is opcode=0x72; rdx; mdx {
  mdx = -rdx;
  resfflags(mdx);
  C_F = 0;
  V_F = 0;
}

:MOVF rfx, mfx is opcode=0x50; rfx; mfx {
  mfx = rfx;
  resfflags(mfx);
  V_F = 0;
}
:MOVD rdx, mdx is opcode=0x70; rdx; mdx {
  mdx = rdx;
  resfflags(mdx);
  V_F = 0;
}

:MULF2 rfx, mfx is opcode=0x44; rfx; mfx {
  mfx = mfx f* rfx;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:MULF3 rfx, rfx2, mfx is opcode=0x45; rfx; rfx2; mfx {
  mfx = rfx f* rfx2;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:MULD2 rdx, mdx is opcode=0x64; rdx; mdx {
  mdx = mdx f* rdx;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}
:MULD3 rdx, rdx2, mdx is opcode=0x65; rdx; rdx2; mdx {
  mdx = rdx f* rdx2;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}

:POLYF rfx, mwx, eab_a is opcode=0x55; rfx; mwx; eab_a {
  mwx = 0; # FIXME
}
:POLYD rdx, mwx, eab_a is opcode=0x75; rdx; mwx; eab_a {
  mwx = 0; # FIXME
}

:SUBF2 rfx, mfx is opcode=0x42; rfx; mfx {
  mfx = mfx f- rfx;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:SUBF3 rfx, rfx2, mfx is opcode=0x43; rfx; rfx2; mfx {
  mfx = rfx f- rfx2;
  resfflags(mfx);
  V_F = 0;
  C_F = 0;
}
:SUBD2 rdx, mdx is opcode=0x62; rdx; mdx {
  mdx = mdx f- rdx;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}
:SUBD3 rdx, rdx2, mdx is opcode=0x63; rdx; rdx2; mdx {
  mdx = rdx f- rdx2;
  resfflags(mdx);
  V_F = 0;
  C_F = 0;
}

:TSTF rfx is opcode=0x53; rfx {
  resfflags(rfx);
  V_F = 0;
  C_F = 0;
}
:TSTD rdx is opcode=0x73; rdx {
  resfflags(rdx);
  V_F = 0;
  C_F = 0;
}

#=========================================================================
# Character-String Instructions
#=========================================================================
# FIXME

:CMPC3 rwx, eab_a, eab_a2 is opcode=0x29; rwx; eab_a; eab_a2 unimpl
:CMPC5 rwx, eab_a, eab, rwx2, eab_a2 is opcode=0x2d; rwx; eab_a; eab; rwx2; eab_a2 unimpl
:LOCC eab, eaw, eab_a is opcode=0x3a; eab; eaw; eab_a unimpl
:MATCHC rwx, eab_a, rwx2, eab_a2 is opcode=0x39; rwx; eab_a; rwx2; eab_a2 unimpl
:MOVC3 rwx, eab_a, eab_a2 is opcode=0x28; rwx; eab_a; eab_a2 unimpl
:MOVC5 rwx, eab_a, eab, rwx2, eab_a2 is opcode=0x2c; rwx; eab_a; eab; rwx2; eab_a2 unimpl
:MOVTC rwx, eab_a, eab, eab_a2, rwx2, eab_a3 is opcode=0x2e; rwx; eab_a; eab; eab_a2; rwx2; eab_a3 unimpl
:MOVTUC rwx, eab_a, eab, eab_a2, rwx2, eab_a3 is opcode=0x2f; rwx; eab_a; eab; eab_a2; rwx2; eab_a3 unimpl
:SCANC rwx, eab_a, eab_a2, rbx is opcode=0x2a; rwx; eab_a; eab_a2; rbx unimpl
:SKPC rbx, rwx, eab_a is opcode=0x3b; rbx; rwx; eab_a unimpl
:SPANC rwx, eab_a, eab_a2, rbx is opcode=0x2b; rwx; eab_a; eab_a2; rbx unimpl

#=========================================================================
# Cyclic Redundancy Check Instructions
#=========================================================================
# FIXME

:CRC is opcode=0x0b unimpl

#=========================================================================
# Decimal-String Instructions
#=========================================================================
# FIXME

:ADDP4 is opcode=0x20 unimpl
:ADDP6 is opcode=0x21 unimpl
:ASHP is opcode=0xf8 unimpl
:CMPP3 is opcode=0x35 unimpl
:CMPP4 is opcode=0x37 unimpl
:CVTLP is opcode=0xf9 unimpl
:CVTPL is opcode=0x36 unimpl
:CVTPS is opcode=0x08 unimpl
:CVTPT is opcode=0x24 unimpl
:CVTSP is opcode=0x09 unimpl
:CVTTP is opcode=0x26 unimpl
:DIVP is opcode=0x27 unimpl
:MOVP is opcode=0x34 unimpl
:MULP is opcode=0x25 unimpl
:SUBP4 is opcode=0x22 unimpl
:SUBP6 is opcode=0x23 unimpl

#=========================================================================
# Edit Instructions
#=========================================================================
# FIXME


#=========================================================================
# Validating Address Arguments
#=========================================================================
# FIXME

:PROBER rbx, rwx, eab_a is opcode=0x0c; rbx; rwx; eab_a {
  N_F = 0;
  Z_F = 0; # assume readable
  V_F = 0;
}

:PROBEW rbx, rwx, eab_a is opcode=0x0d; rbx; rwx; eab_a {
  N_F = 0;
  Z_F = 0; # assume writable
  V_F = 0;
}


#=========================================================================
# Instructions related to exceptions and interrupts
#=========================================================================
# FIXME

:REI is opcode=0x02 unimpl
:CHMK is opcode=0xbc unimpl
:CHME is opcode=0xbd unimpl
:CHMS is opcode=0xbe unimpl
:CHMU is opcode=0xbf unimpl

#=========================================================================
# Process-Structure Instructions
#=========================================================================
# FIXME

:LDPCTX is opcode=0x06 unimpl
:SVPCTX is opcode=0x07 unimpl

# move to processor register
:MTPR rlx, procreg is opcode=0xda; rlx; procreg {
  procreg = rlx;
}
# move from processor register
:MFPR procreg, mlx is opcode=0xdb; procreg; mlx {
  mlx = procreg;
}

